<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode 2641 二叉树的堂兄弟节点 II</title>
      <link href="/blog/2023/04/28/LeetCode%202641%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%20II/"/>
      <url>/blog/2023/04/28/LeetCode%202641%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%20II/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/cousins-in-binary-tree-ii/">题目链接</a></p><p><font face="consolas"><br>给你一棵二叉树的根 root ，请你将每个节点的值替换成该节点的所有 堂兄弟节点值的和 。</p><p><font face="consolas"><br>如果两个节点在树中有相同的深度且它们的父节点不同，那么它们互为 堂兄弟 。<br>请你返回修改值之后，树的根 root 。</p><p><strong>注意，一个节点的深度指的是从树根节点到这个节点经过的边数。</strong></p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><p><img src="https://img-blog.csdnimg.cn/a1608aeed3bc411e81be271a886b790c.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,9,1,10,null,7]</span><br><span class="line">输出：[0,0,0,7,7,null,11]</span><br><span class="line">解释：上图展示了初始的二叉树和修改每个节点的值之后的二叉树。</span><br><span class="line">- 值为 5 的节点没有堂兄弟，所以值修改为 0 。</span><br><span class="line">- 值为 4 的节点没有堂兄弟，所以值修改为 0 。</span><br><span class="line">- 值为 9 的节点没有堂兄弟，所以值修改为 0 。</span><br><span class="line">- 值为 1 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。</span><br><span class="line">- 值为 10 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。</span><br><span class="line">- 值为 7 的节点有两个堂兄弟，值分别为 1 和 10 ，所以值修改为 11 。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><p><img src="https://img-blog.csdnimg.cn/95fe95cfc245480483e2ba8ac4689ce5.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,1,2]</span><br><span class="line">输出：[0,0,0]</span><br><span class="line">解释：上图展示了初始的二叉树和修改每个节点的值之后的二叉树。</span><br><span class="line">- 值为 3 的节点没有堂兄弟，所以值修改为 0 。</span><br><span class="line">- 值为 1 的节点没有堂兄弟，所以值修改为 0 。</span><br><span class="line">- 值为 2 的节点没有堂兄弟，所以值修改为 0 。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceValueInTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        q = deque([root])</span><br><span class="line">        cnt = Counter()  <span class="comment"># 存当前节点所有儿子节点的值的和</span></span><br><span class="line">        father = <span class="built_in">dict</span>()  <span class="comment"># 存每个节点的父亲节点</span></span><br><span class="line">        father[root] = <span class="number">0</span>  <span class="comment"># 根节点的父亲节点</span></span><br><span class="line">        cnt[<span class="number">0</span>] = root.val</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp = q</span><br><span class="line">            q = []</span><br><span class="line">            s = <span class="built_in">sum</span>(node.val <span class="keyword">for</span> node <span class="keyword">in</span> tmp)  <span class="comment"># 求当前层所有节点的值的和</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> tmp:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    cnt[node] += node.left.val</span><br><span class="line">                    father[node.left] = node</span><br><span class="line">                    q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    cnt[node] += node.right.val</span><br><span class="line">                    father[node.right] = node</span><br><span class="line">                    q.append(node.right)</span><br><span class="line">                node.val = s - cnt[father[node]]</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask 开发问题总结</title>
      <link href="/blog/2022/08/27/Flask%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/blog/2022/08/27/Flask%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><font face="comic sans ms">毕设用 Flask 框架开发了一个 Web 网站 ，在开发过程中遇到了很多问题，今天这里做一个总结，避免以后遇到同样的问题。</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 问题代码</span></span><br><span class="line">Error: <span class="keyword">While</span> importing <span class="string">&#x27;xxx&#x27;</span>, an ImportError was raised.</span><br></pre></td></tr></table></figure><p><font face="comic sans ms">import 语句有误，检查所有 py 文件里的 import 语句，可能的错误一种是包名有误，另一种是引用其他 py 文件里的函数时需要给出完整路径 “项目名.文件夹名.文件名.函数名” 的形式<br>注意直接使用 flask run 指令运行项目时报错很模糊，可以直接在编译器上运行 app.py 文件，这样可以获得比较清晰的错误提示</p><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">云服务器上用 flask run 命令运行项目后，本地输入云服务器 ip 无法访问</span><br></pre></td></tr></table></figure><p>在运行指令后加上主机地址以监听所有外部请求，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask run --host=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure></p><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 问题代码</span></span><br><span class="line">TypeError: Rule.__init__() got an unexpected keyword argument <span class="string">&#x27;method&#x27;</span></span><br></pre></td></tr></table></figure><p><font face="comic sans ms">视图函数的装饰器里的 method 漏了 s，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误代码</span></span><br><span class="line">user_bp.route(<span class="string">&#x27;/settings/data&#x27;</span>, method=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>])</span><br></pre></td></tr></table></figure></p><h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题 4"></a>问题 4</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 问题代码</span></span><br><span class="line">AssertionError: View <span class="function"><span class="keyword">function</span> <span class="title">mapping</span> <span class="title">is</span> <span class="title">overwriting</span> <span class="title">an</span> <span class="title">existing</span> <span class="title">endpoint</span> <span class="keyword">function</span>: <span class="title">blog</span>.<span class="title">change_theme</span></span></span><br></pre></td></tr></table></figure><p><font face="comic sans ms">函数名重复，文件中有两个 change_theme 函数</p><h3 id="问题-5"><a href="#问题-5" class="headerlink" title="问题 5"></a>问题 5</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: The view <span class="function"><span class="keyword">function</span> <span class="title">for</span> &#x27;<span class="title">xxx</span>&#x27; <span class="title">did</span> <span class="title">not</span> <span class="title">return</span> <span class="title">a</span> <span class="title">valid</span> <span class="title">response</span>. <span class="title">The</span> <span class="keyword">function</span> <span class="title">either</span> <span class="title">returned</span> <span class="title">None</span> <span class="title">or</span> <span class="title">ended</span> <span class="title">without</span> <span class="title">a</span> <span class="title">return</span> <span class="title">statement</span>.</span></span><br></pre></td></tr></table></figure><p><font face="comic sans ms">视图函数中的 return 位置有误，通常是多余的 tab 键导致函数缺少返回语句</p><h3 id="问题-6"><a href="#问题-6" class="headerlink" title="问题 6"></a>问题 6</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误代码</span></span><br><span class="line">TypeError: <span class="string">&#x27;bool&#x27;</span> object is not callable</span><br><span class="line"><span class="comment"># 错误处</span></span><br><span class="line"><span class="keyword">if</span> current_user.is_admin()</span><br></pre></td></tr></table></figure><p>注意属性和方法的区别，属性不需要加括号，方法需要加括号</p><h3 id="问题-7"><a href="#问题-7" class="headerlink" title="问题 7"></a>问题 7</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误代码</span></span><br><span class="line">Method Not Allowed.The method is not allowed <span class="keyword">for</span> the requested URL.</span><br></pre></td></tr></table></figure><p><font face="comic sans ms">视图函数里只有 post 方法而没有 request 方法，所以直接访问会报错</p><h3 id="问题-8"><a href="#问题-8" class="headerlink" title="问题 8"></a>问题 8</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误代码</span></span><br><span class="line">RuntimeError</span><br><span class="line">RuntimeError: Working outside of request context.</span><br><span class="line"></span><br><span class="line">This typically means that you attempted to use functionality that needed</span><br><span class="line">an active HTTP request. Consult the documentation on testing <span class="keyword">for</span></span><br><span class="line">information about how to avoid this problem.</span><br></pre></td></tr></table></figure><p><font face="comic sans ms">flask 中的 request 对象只能在视图函数下使用，在其他地方使用会报错</p><h3 id="问题-9"><a href="#问题-9" class="headerlink" title="问题 9"></a>问题 9</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误代码</span></span><br><span class="line">sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (<span class="number">2003</span>, <span class="string">&quot;Can&#x27;t connect to MySQL server on &#x27;@rm-bp1o019zha4dfz18h2o.mysql.rds.aliyuncs.com&#x27; ([Errno 11003] getaddrinfo failed)&quot;</span>)</span><br></pre></td></tr></table></figure><p><font face="comic sans ms">因为 password 中有特殊字符导致无法正常连接数据库，一般是密码中含有 @ 字符，修改密码即可解决</p><h3 id="问题-10"><a href="#问题-10" class="headerlink" title="问题 10"></a>问题 10</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误代码</span></span><br><span class="line">sqlalchemy.exc.InvalidRequestError: Mapper <span class="string">&#x27;mapped class User-&gt;user&#x27;</span> has no property <span class="string">&#x27;role&#x27;</span></span><br></pre></td></tr></table></figure><p><font face="comic sans ms">User 模型中未添加 role 属性</p><h3 id="问题-11"><a href="#问题-11" class="headerlink" title="问题 11"></a>问题 11</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlalchemy.exc.InvalidRequestError: Could not locate a property which relates instances of <span class="class"><span class="keyword">class</span> &#x27;<span class="title">Collect</span>&#x27; <span class="title">to</span> <span class="title">instances</span> <span class="title">of</span> <span class="title">class</span> &#x27;<span class="title">User</span>&#x27;</span></span><br></pre></td></tr></table></figure><p><font face="comic sans ms">Collect 模型和 User 模型之间未建立联系</p><h3 id="问题-12"><a href="#问题-12" class="headerlink" title="问题 12"></a>问题 12</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误代码</span></span><br><span class="line">SAWarning: Attribute <span class="string">&#x27;BSCV</span></span><br><span class="line"><span class="string">A&#x27;</span> on <span class="class"><span class="keyword">class</span> &lt;<span class="title">class</span> &#x27;<span class="title">mw</span>.<span class="title">models</span>.<span class="title">Cornea</span>&#x27;&gt; <span class="title">appears</span> <span class="title">to</span> <span class="title">be</span> <span class="title">a</span> <span class="title">non</span>-<span class="title">schema</span> &#x27;<span class="title">sqlalchemy</span>.<span class="title">sql</span>.<span class="title">column</span>()&#x27; <span class="title">object</span>; <span class="title">this</span> <span class="title">won</span>&#x27;<span class="title">t</span> <span class="title">be</span> <span class="title">part</span> <span class="title">of</span> <span class="title">the</span> <span class="title">declarative</span> <span class="title">mapping</span></span></span><br><span class="line"><span class="class"># 错误处</span></span><br><span class="line"><span class="class"><span class="title">BSCVA</span> = <span class="title">db</span>.<span class="title">column</span>(<span class="title">db</span>.<span class="title">DECIMAL</span>(2, 1))</span></span><br></pre></td></tr></table></figure><p><font face="comic sans ms">column 首字母未大写，导致数据库表声明错误</p><h3 id="问题-13"><a href="#问题-13" class="headerlink" title="问题 13"></a>问题 13</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误代码</span></span><br><span class="line">AttributeError: <span class="string">&#x27;User&#x27;</span> object has no attribute <span class="string">&#x27;translate&#x27;</span></span><br></pre></td></tr></table></figure><p>数据提交到数据库时类型有误，如代码所示，此时需要检查提交到 User 表中的所有数据类型是否和声明一致</p><h3 id="问题-14"><a href="#问题-14" class="headerlink" title="问题 14"></a>问题 14</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlalchemy.exc.NoForeignKeysError: Could not determine join condition between parent/child tables on relationship User.comments - there</span><br><span class="line"> are no foreign keys linking these tables.  Ensure that referencing columns are associated with a ForeignKey or ForeignKeyConstraint, o</span><br><span class="line"><span class="built_in">r</span> specify a <span class="string">&#x27;primaryjoin&#x27;</span> expression. </span><br></pre></td></tr></table></figure><p>关系建立有误，可以将目标表的关系逐一对照查错</p><h3 id="问题-15"><a href="#问题-15" class="headerlink" title="问题 15"></a>问题 15</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smtplib.SMTPServerDisconnected: please run connect() first</span><br></pre></td></tr></table></figure><p>使用 smtp 服务发送邮件时报错，服务涉及的账号密码等都存在 .env 文件中，Flask 会自动读取 .env 文件里的参数，但是该文件必须放在项目根目录下，否则会因无法读取报错</p><h3 id="问题-16"><a href="#问题-16" class="headerlink" title="问题 16"></a>问题 16</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.port = int(port)</span><br><span class="line">ValueError: invalid literal <span class="keyword">for</span> int() with base <span class="number">10</span>: <span class="string">&#x27;None&#x27;</span></span><br></pre></td></tr></table></figure><p><font face="comic sans ms">SQLAlchemy 把一个引擎的源表示为一个连同设定引擎选项的可选字符串参数的 URI，URI 的形式是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> self.registry[key]</span><br><span class="line">KeyError: <span class="number">140581010807680</span></span><br><span class="line">dialect+driver://username:password@host:port/database</span><br></pre></td></tr></table></figure><p><font face="comic sans ms">出现上述错误的原因是程序未读出 URI 中的 port，此时要检查环境变量配置文件，如果配置准确无误但还是无法读出配置文件中的 port 值注意以下问题：</p><p><font face="comic sans ms">在开发时，因为安装了 python-dotenv，使用 flask run 命令启动开发服务器时 Flask 会自动导入存储在 .flaskenv 或 .env 文件中的环境变量。在生产环境下，我们需要使用性能更高的生产服务器，所以不能再使用这个命令启动程序，这时我们需要手动导入环境变量。</p><p><font face="comic sans ms">我们应该尽可能地提前导入环境变量操作，这样才能确保程序中获取环境变量的代码正常工作，因此最佳的导入位置就是在 wsgi.py 脚本中，其次是程序包构造文件的顶部。在wsgi.py脚本中，我们使用 python-dotenv 提供的 load_dotenv() 函数手动导入 .env 文件中设置的环境变量，如下所示：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from dotenv import load_dotenv</span><br><span class="line"></span><br><span class="line">dotenv_path = os.path.join(os.path.dirname(__file__), <span class="string">&#x27;.env&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> os.path.exists(dotenv_path):</span><br><span class="line">load_dotenv(dotenv_path)</span><br><span class="line"></span><br><span class="line">from bluelog import create_app</span><br><span class="line">app = create_app(<span class="string">&#x27;production&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面这段代码中的顺序非常重要，手动导入环境变量的语句必须在最前面，否则会导致一些环境变量无法读出造成程序崩溃。</p><h3 id="问题-17"><a href="#问题-17" class="headerlink" title="问题 17"></a>问题 17</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: <span class="string">&#x27;int&#x27;</span> object has no attribute <span class="string">&#x27;_sa_instance_state&#x27;</span></span><br></pre></td></tr></table></figure><p><font face="comic sans ms">Flask 数据库外键字段在创建对象赋值时，需要赋值对象，而不是该对象的 id 或者其他单独的字段。</p>]]></content>
      
      
      <categories>
          
          <category> Python小项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/blog/2021/11/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/blog/2021/11/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="我的第一篇博客文章"><a href="#我的第一篇博客文章" class="headerlink" title="我的第一篇博客文章"></a>我的第一篇博客文章</h1><p>这是我自建博客网站的第一篇文章，从18年至今，已经写了两年多的博客了，唯一值得骄傲的是我从未放弃，一直坚持了下来，之前的博客都在CSDN，<a href="http://zaizai.blog.csdn.net">博客链接</a>。为什么选择CSDN？因为方便+大众，现在闲下来无事就创了自己的博客网站，因为CSDN也有它无法避免的缺点，就是界面不够美观。<br>之前在CSDN的博客绝大部分都和ACM相关，这个博客网站就准备放一些我自己做的小项目和心得体会，谢谢大家一直以来的支持，我仍会继续努力，写出更高质量更高水平的博客！</p><p><img src="https://img-blog.csdnimg.cn/20210203102123194.jpeg" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 个人 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>致所有热爱这个专业的小伙伴们的一封信</title>
      <link href="/blog/2021/11/05/%E8%87%B4%E6%89%80%E6%9C%89%E7%83%AD%E7%88%B1%E8%BF%99%E4%B8%AA%E4%B8%93%E4%B8%9A%E7%9A%84%E5%B0%8F%E4%BC%99%E4%BC%B4%E4%BB%AC%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/"/>
      <url>/blog/2021/11/05/%E8%87%B4%E6%89%80%E6%9C%89%E7%83%AD%E7%88%B1%E8%BF%99%E4%B8%AA%E4%B8%93%E4%B8%9A%E7%9A%84%E5%B0%8F%E4%BC%99%E4%BC%B4%E4%BB%AC%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;<font face="黑体">今天是 <font face="consolas">1024</font> 程序员节，是我步入这个专业的第四个年头，同样也是我在 <font face="consolas">CSDN</font> 坚持写博客的第三个年头。从最近的一篇博客至今，已经四个多月未写作了，所以借此机会我想聊聊自己的计算机生涯，下面所有的话都是有感而发，不喜勿喷哦😁</p><hr><p>&ensp;&ensp;&ensp;&ensp;<font face="黑体">第一句话我想送给所有学弟学妹或者即将步入大学生活的同学们：</font><br>&ensp;&ensp;&ensp;&nbsp;&nbsp;<strong>时光如白驹过隙，大一不努力，大四徒伤悲。</strong><br>&ensp;&ensp;&ensp;&ensp;<font face="黑体">当我回过神来时蓦然发现，大学四年已经走到了尾声，遥想当年刚步入大学时，我还是个未成年的孩子，一眨眼就到了奔三的年纪</font>[<font face="黑体">此处手动添加一颗沧桑的熊猫头</font>🙁]<font face="黑体">。自我反思时，我很庆幸自己没有荒废三年时光。半夜十二点在电脑屏幕前对着 <font face="consolas">Codeforces</font> 的题目抓耳挠腮、打牛客暑期学校时苦思冥想几个小时终于 <font face="consolas">AC</font> 的喜悦、早上六点多爬起来赶地铁去打蓝桥杯的辛苦、银川站打铁走在瑟瑟冷风中的宁夏理工学院的心酸、过年熬夜几天狂肝美赛论文的充实、准备一次又一次互联网+答辩的紧张，这些都历历在目。<br>&ensp;&ensp;&ensp;&ensp;但是如果当初我没有做这些事呢？如果我只是整天呆在宿舍里打打游戏，混混日子，那我会有今天的成就吗？答案是否定的。我的身边不乏高中从尖子班来的同学，也不乏普通高中的前几名进来的，但是他们中有人挂科太多强制转下，有人碌碌无为只能慌忙准备考研，有人找工作频频被拒，这些人的失败有很大程度是因为虚度时光，所以我从过来人的角度告诫你们，<strong>光阴似箭</strong>，一眨眼可能就发现自己的大学时光已接近尾声，而我不希望那时的你们一事无成，所以请务必珍惜自己的大学时光，不要老大徒伤悲！</p><hr><p>&ensp;&ensp;&ensp;&ensp;<font face="黑体">第二句我想说的话是：</font><br>&ensp;&ensp;&ensp;&nbsp;&nbsp;<strong>当你决心去做一件事情的时候，全世界都会为你让路。</strong></p><p><font face="黑体">&ensp;&ensp;&ensp;&ensp;这句话是我当时准备保研时一直作为 <font face="consolas">QQ</font> 签名鼓励自己的，这里给各位讲一下自己的保研之路吧。我是大三上学期才开始准备保研的，那时候我的绩点排名是多少呢？全院 <font face="consolas">232</font> 个人，我排 <font face="consolas">87</font> 名，大概 <font face="consolas">37%</font> 左右，而我们院正常的保研比例只有 <font face="consolas">14%</font>，如果我没提保研成功的话，几乎所有人都觉得不可能吧，甚至在夏令营阶段找学院领导签字时，老师也觉得我没有希望，但我最终创造了奇迹，在所有保研人里以绩点倒数第一，综测倒数第三的成绩顺利保研。<br>&ensp;&ensp;&ensp;&ensp;我想成功的秘诀就在于做这件事情的时候，我首先并不是去考虑结果，而是竭尽全力地去做，因为你做了哪怕只有一丝机会都有可能成功，但是如果你畏手畏脚不敢下手，就毫无机会了。整个大三学年里我没出去看过一次电影，几乎没有娱乐活动，考试周过了就准备竞赛、写论文、做项目，结果是这一年里，我取得了多项程序设计竞赛的国奖，申请了发明专利和软著，也发表了 <font face="consolas">EI</font> 会议论文，把保研竞赛加分提到了满分，最终上天不负有心人，我成功拿到了保研名额。说这么多，我是想用亲身经历告诉各位，只要你想，没有什么是不可能的。正如苹果的乔布斯所言，“只有那些疯狂到自以为可以改变世界的人，最后才真的改变了世界。”</p><hr><p>&ensp;&ensp;&ensp;&ensp;<font face="黑体">最后一句话就是：</font><br>&ensp;&ensp;&ensp;&nbsp;&nbsp;<strong>人生不如意之事十之八九，与其在遗憾中沉沦，不如在厚积中薄发。</strong><br>&ensp;&ensp;&ensp;&ensp;<font face="黑体">大家在看完上面的内容时，一定觉得我很厉害，一直在装 <font face="consolas">X</font>，其实不是的，我一路走来有太多太多的遗憾了，取少部分列举如下：</p><ul><li><font face="黑体">我的高考目标是南京大学的天文系，但是很遗憾，因为个人的一些原因未能如愿以偿，现在只是一个 <font face="consolas">211</font> 计算机专业的普通学生。</li><li><font face="黑体">我在校 <font face="consolas">ACM</font> 队呆了近三年，参加了三次 <font face="consolas">ICPC</font> 和一次 <font face="consolas">CCPC</font>，都未能获奖</li><li><font face="黑体">我保研阶段拿到重大，北邮，川大的 <font face="consolas">offer</font>，最终因为不敢冒险选择了本校</li><li>$\cdots$</li></ul><p>&ensp;&ensp;&ensp;&ensp;<font face="黑体">诚然，我相信每个人都有遗憾，爱而不得、劳而不获诸如此类，月尚有阴晴圆缺，作为凡人又何求十全十美呢。就拿竞赛这条路来说，当你总是在抱怨这抱怨那时，请记住，有太多太多条件比你差的同学仍无怨无悔地在这条路上默默耕耘着，我写博客时碰到很多出身普通一本甚至二三本学校还在努力打 <font face="consolas">ACM</font> 的同学，他们学校和自身条件可能都不好，但是他们并没有怨天尤人，一直都在虚心求教，我相信他们最终都会取得满意的成绩。与其把时间浪费在自我怀疑和抱怨外部条件上，不如静下心来去刷两道题；与其抱怨这难那难，不如去请教学长老师搞懂这个难点；与其在遗憾中沉沦，不如在厚积中薄发。很多时候抱怨解决不了问题，改变自己才是破局之策。</p><hr><p>&ensp;&ensp;&ensp;&ensp;<font face="黑体">对程序设计竞赛的热爱让我选择了这个专业，也支撑着我的 <font face="consolas">CSDN</font> 博客走到今天。今后有缘的话，我应该还会更新一些题解，不过博客的重心应该都会以项目为主了[毕竟要做研狗了/(ㄒoㄒ)/~~]。这里强烈建议搞竞赛的养成写博客的习惯，坚持下来你一定会看到别样的风景(๑•̀ㅂ•́)و✧</p><p>&ensp;&ensp;&ensp;&ensp;<font face="黑体">最后的最后，在这个只属于程序员的节日里，送上我衷心的祝福：<br>&ensp;&ensp;&ensp;&ensp;作为一个退役的 <font face="consolas">ACM</font> 选手，衷心希望在这条路上努力的同学们题题 <font face="consolas">AC</font>，场场 <font face="consolas">AK</font>，奖牌拿到手软！<br>&ensp;&ensp;&ensp;&ensp;作为一个即将读研的小白，希望所有考研人都能圆梦心仪的学校，也祝我们读研的道路上都能保住秀发，论文狂发！<br>&ensp;&ensp;&ensp;&ensp;作为一个憧憬工作的憨憨，希望所有打工人都能朝九晚五，月薪过万！<br>&ensp;&ensp;&ensp;&ensp;作为一个 <font face="consolas">IT</font> 领域的人，希望这个行业发展越来越好，希望未来改变世界的，就是我们这些默默发光的程序员们！</p>]]></content>
      
      
      <categories>
          
          <category> 个人 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年广东工业大学第十五届文远知行杯程序设计竞赛（同步赛）B.找山坡</title>
      <link href="/blog/2021/10/05/2021%E5%B9%B4%E5%B9%BF%E4%B8%9C%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8A%E6%96%87%E8%BF%9C%E7%9F%A5%E8%A1%8C%E6%9D%AF%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%EF%BC%88%E5%90%8C%E6%AD%A5%E8%B5%9B%EF%BC%89B.%E6%89%BE%E5%B1%B1%E5%9D%A1/"/>
      <url>/blog/2021/10/05/2021%E5%B9%B4%E5%B9%BF%E4%B8%9C%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8A%E6%96%87%E8%BF%9C%E7%9F%A5%E8%A1%8C%E6%9D%AF%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%EF%BC%88%E5%90%8C%E6%AD%A5%E8%B5%9B%EF%BC%89B.%E6%89%BE%E5%B1%B1%E5%9D%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/13504/B">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><font face="consolas">母牛哥在电脑面前坐久了，想站起来看看窗外的小山坡，于是就想出了这个问题：<br>给定一个大小为 n 的数组 a，序号从 1 开始，<br>计算:</p><p><font face="consolas">max{ R - L | 1 &lt;= L &lt;= R &lt;= n, a[L] == a[R], 对于所有i (L &lt;= i &lt;= R), 满足a[i] &gt;= a[L] }.</p><p>也就是找到两个坐标,这两个坐标的值相等,并且他们之间的值都大于等于这两个坐标上的值.<br>这两个坐标相减最大能是多少.</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p><font face="consolas">第一行一个整数 n，第二行 n 个整数</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出题目所求的值</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 2 1</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>单调栈~<br>单调栈里元素值递增，当当前元素小于栈顶元素时，一直弹出栈顶即可，直到出现以下三种情况：</p><ul><li>栈为空，此时直接压入元素即可</li><li><font face="consolas">栈顶元素等于当前元素，将两者下标之差和答案取 max</li><li>栈顶元素小于当前元素，压入元素即可</li></ul><p>AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans, a[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; a[i] &lt; a[s.<span class="built_in">top</span>()]) s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) s.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[s.<span class="built_in">top</span>()]) ans = <span class="built_in">max</span>(ans, i - s.<span class="built_in">top</span>());</span><br><span class="line">        <span class="keyword">else</span> s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1143 最长公共子序列</title>
      <link href="/blog/2021/04/03/LeetCode%201143%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/blog/2021/04/03/LeetCode%201143%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">题目链接</a></p><p><font face="consolas">给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p><font face="consolas">例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><p><font face="consolas">经典 DP ~</p><p><font face="consolas">用 dp[i][j] 表示字符串1 [0,i-1] 位置和字符串2 [0,j-1] 位置的最大公共子序列的长度，那么有如下状态转移方程：</p><ol><li><font face="consolas">对当前位置 i，j，若有 text1[i-1]=text2[j-1]，则有 dp[i][j]=dp[i-1][j-1]+1</li><li><font face="consolas">对当前位置 i，j，最大答案即为：dp[i][j]=max{dp[i][j],dp[i][j-1],dp[i-1][j]}</li></ol><p><font face="consolas">AC 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = text1.<span class="built_in">size</span>(), m = text2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> a = text1[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="type">char</span> b = text2[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (a == b) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(&#123;dp[i][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 面试题 17.21. 直方图的水量</title>
      <link href="/blog/2021/04/03/LeetCode%20%E9%9D%A2%E8%AF%95%E9%A2%98%2017.21.%20%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F/"/>
      <url>/blog/2021/04/03/LeetCode%20%E9%9D%A2%E8%AF%95%E9%A2%98%2017.21.%20%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/">题目链接</a></p><p><font face="consolas">给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。<br><img src="https://img-blog.csdnimg.cn/20210403165507288.png" alt="在这里插入图片描述"></p><p><font face="consolas">上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 感谢 Marcos 贡献此图。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p>单调栈~<br>首先我们不妨思考一下，什么时候能存水，肯定要出现两高夹一低才行，此时我们把存的水看作是一个矩形，假设遍历到某一高度 $i$ 时，出现了两高夹一低的情况，中间下标为 $top$，左侧为 $left$，那么这个矩形的宽就是 $i-left-1$，高就是 $min(height[i],height[left])-height[top]$。综上，只要每出现一次两高夹一低时，把矩形面积加到答案里即可~<br>而我们需要用一个数据结构来维护高度，显然高度是要递增的，所以很容易想到单调栈，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> top = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">int</span> left = s.<span class="built_in">top</span>();</span><br><span class="line">                <span class="type">int</span> w = i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> h = <span class="built_in">min</span>(height[left], height[i]) - height[top];</span><br><span class="line">                ans += h * w;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 61 旋转链表</title>
      <link href="/blog/2021/03/27/LeetCode%2061%20%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/blog/2021/03/27/LeetCode%2061%20%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/rotate-list/">题目链接</a></p><p><font face="consolas">给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><p><img src="https://img-blog.csdnimg.cn/20210327103551873.png?" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2,3,4,5], k = 2</span><br><span class="line">输出：[4,5,1,2,3]</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><p><img src="https://img-blog.csdnimg.cn/20210327103615484.png?" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [0,1,2], k = 4</span><br><span class="line">输出：[2,0,1]</span><br></pre></td></tr></table></figure><p><font face="consolas">简单链表操作，我们注意到移动的次数 k 可能会大于链表长度，所以必须要取模，这样一来移动的可能性只会为 [0,len-1]，而 0 就相当于没移动，所以我们只需要只需要遍历一下列表，将左边 len-k 的部分拼接到右边的末尾即可，AC 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotateRight</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:  <span class="comment"># 判空</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        cnt, l = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        p = head  <span class="comment"># 计算链表长度</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        p = head</span><br><span class="line">        left = p  <span class="comment"># 链表右移的部分</span></span><br><span class="line">        k = k % l <span class="keyword">if</span> k % l <span class="keyword">else</span> l  <span class="comment"># 取模</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == l - k:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:  <span class="comment"># 移到距离刚好等于链表长度的话相当于没动</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        right = p.<span class="built_in">next</span>  <span class="comment"># 链表左移的部分</span></span><br><span class="line">        p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        p = right</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = left</span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder Beginner Contest 196 E.Filters</title>
      <link href="/blog/2021/03/26/AtCoder%20Beginner%20Contest%20196%20E.Filters/"/>
      <url>/blog/2021/03/26/AtCoder%20Beginner%20Contest%20196%20E.Filters/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc196/tasks/abc196_e">题目链接</a></p><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a><font face="Consolas">Problem Statement</h2><p><font face="Consolas">Given are integer sequences $A=(a_1,a_2,…,a_N)$, $T=(t_1,t_2,…,t_N)$, and $X=(x_1,x_2,…,x_Q)$.<br>Let us define $N$ functions $f_1(x),f_2(x),…,f_N(x)$<br> as follows:</p><script type="math/tex; mode=display">f_i(x)=\begin{cases}x+a_i\ (t_i=1)\\max(x,a_i)\ (t_i=2)\\min(x,a_i)\ (t_i=3)\end{cases}</script><h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a><font face="Consolas">Sample Input 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">-10 2</span><br><span class="line">10 1</span><br><span class="line">10 3</span><br><span class="line">5</span><br><span class="line">-15 -10 -5 0 5</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a><font face="Consolas">Sample Output 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>利用几何作图发现上述三个操作总是会形成如下的图形：<br><img src="https://img-blog.csdnimg.cn/20210326190926936.png?" alt="在这里插入图片描述"><br>那么我们只需要维护三个变量：$low$ 下界，$high$ 上界和 $add$ 加数即可，AC代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">low, high, add = -<span class="number">10</span> ** <span class="number">18</span>, <span class="number">10</span> ** <span class="number">18</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    a, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">1</span>:</span><br><span class="line">        low += a</span><br><span class="line">        high += a</span><br><span class="line">        add += a</span><br><span class="line">    <span class="keyword">elif</span> t == <span class="number">2</span>:</span><br><span class="line">        low = <span class="built_in">max</span>(low, a)</span><br><span class="line">        high = <span class="built_in">max</span>(high, a)</span><br><span class="line">    <span class="keyword">elif</span> t == <span class="number">3</span>:</span><br><span class="line">        low = <span class="built_in">min</span>(low, a)</span><br><span class="line">        high = <span class="built_in">min</span>(high, a)</span><br><span class="line">q = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">list</span> = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> s.split()]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">min</span>(high, <span class="built_in">max</span>(low, x + add)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> AtCoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 82 删除排序链表中的重复元素 II</title>
      <link href="/blog/2021/03/25/LeetCode%2082%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/"/>
      <url>/blog/2021/03/25/LeetCode%2082%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">题目链接</a></p><p><font face="consolas">存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。</p><p>返回同样按升序排列的结果链表。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2,3,3,4,4,5]</span><br><span class="line">输出：[1,2,5]</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,1,1,2,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><p>链表操作~<br>我的方法是遍历一遍链表结点，对某一结点 $q$，判断 $q.next$ 的值和 $q.next.next$，如果相等就存下那个值 $val$，新建一个指针右移到值不为 $val$ 的结点上，再把这个结点接到 $q.next$ 上，重复上述操作即可，AC代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        q = ListNode()</span><br><span class="line">        q.<span class="built_in">next</span> = head</span><br><span class="line">        ans = q</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> q.<span class="built_in">next</span> <span class="keyword">and</span> q.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">while</span> q.<span class="built_in">next</span> <span class="keyword">and</span> q.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">and</span> q.<span class="built_in">next</span>.val == q.<span class="built_in">next</span>.<span class="built_in">next</span>.val:</span><br><span class="line">                val = q.<span class="built_in">next</span>.val</span><br><span class="line">                p = q.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">while</span> p <span class="keyword">and</span> p.val == val:</span><br><span class="line">                    p = p.<span class="built_in">next</span></span><br><span class="line">                q.<span class="built_in">next</span> = p</span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1631 最小体力消耗路径</title>
      <link href="/blog/2021/03/22/LeetCode%201631%20%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84/"/>
      <url>/blog/2021/03/22/LeetCode%201631%20%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/">题目链接</a></p><p>你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。</p><p>一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。</p><p>请你返回从左上角走到右下角的最小 体力消耗值 。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><p><img src="https://img-blog.csdnimg.cn/20210215094252680.png?" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [[1,2,2],[3,8,2],[5,3,5]]</span><br><span class="line">输出：2</span><br><span class="line">解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。</span><br><span class="line">这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><p><img src="https://img-blog.csdnimg.cn/20210215094312272.png?" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [[1,2,3],[3,8,4],[5,3,5]]</span><br><span class="line">输出：1</span><br><span class="line">解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。</span><br></pre></td></tr></table></figure><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><p><img src="https://img-blog.csdnimg.cn/20210215094331508.png?" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]</span><br><span class="line">输出：0</span><br><span class="line">解释：上图所示路径不需要消耗任何体力。</span><br></pre></td></tr></table></figure><p> 二分+BFS~<br> 我们可以二分最短距离，每一次从左上角往右下角 BFS 即可，注意 BFS 过程中的标记请尽量用数组完成，map 会非常耗时，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n, dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;heights)</span> </span>&#123;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(m * n)</span></span>;</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, b;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            a = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (a.first == m - <span class="number">1</span> &amp;&amp; a.second == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                b.first = a.first + dir[i][<span class="number">0</span>];</span><br><span class="line">                b.second = a.second + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (b.first &gt;= <span class="number">0</span> &amp;&amp; b.first &lt; m &amp;&amp; b.second &gt;= <span class="number">0</span> &amp;&amp; b.second &lt; n &amp;&amp; !vis[b.first * n + b.second] &amp;&amp;</span><br><span class="line">                    <span class="built_in">abs</span>(heights[a.first][a.second] - heights[b.first][b.second]) &lt;= x) &#123;</span><br><span class="line">                    vis[b.first * n + b.second] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumEffortPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;heights)</span> </span>&#123;</span><br><span class="line">        m = heights.<span class="built_in">size</span>(), n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1000000</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid, heights)) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> BFS </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1579 保证图可完全遍历</title>
      <link href="/blog/2021/03/22/LeetCode%201579%20%E4%BF%9D%E8%AF%81%E5%9B%BE%E5%8F%AF%E5%AE%8C%E5%85%A8%E9%81%8D%E5%8E%86/"/>
      <url>/blog/2021/03/22/LeetCode%201579%20%E4%BF%9D%E8%AF%81%E5%9B%BE%E5%8F%AF%E5%AE%8C%E5%85%A8%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/">题目链接</a></p><p>Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3  种类型的边：</p><ul><li>类型 1：只能由 Alice 遍历。</li><li>类型 2：只能由 Bob 遍历。</li><li>类型 3：Alice 和 Bob 都可以遍历。</li></ul><p>给你一个数组 edges ，其中 edges[i] = [typei, ui, vi] 表示节点 ui 和 vi 之间存在类型为 typei 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。</p><p>返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><p><img src="https://img-blog.csdnimg.cn/20210214115046550.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]</span><br><span class="line">输出：2</span><br><span class="line">解释：如果删除 [1,1,2] 和 [1,1,3] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><p><img src="https://img-blog.csdnimg.cn/20210214115100293.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]</span><br><span class="line">输出：0</span><br><span class="line">解释：注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。</span><br></pre></td></tr></table></figure><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><p><img src="https://img-blog.csdnimg.cn/20210214115113866.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。</span><br></pre></td></tr></table></figure><p>这题就是比较简单的并查集，我们分别对两个人建立一个并查集，先删公共边中的累赘边，再分别删各自独占边中的累赘边即可，AC代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Unionset</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; father;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sum;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        father.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) father[i] = i;</span><br><span class="line">        sum.<span class="built_in">resize</span>(n);</span><br><span class="line">        cnt = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findFather</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == father[x] ? x : father[x] = <span class="built_in">findFather</span>(father[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">findFather</span>(x), y = <span class="built_in">findFather</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum[x] &lt; sum[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        father[y] = x;</span><br><span class="line">        sum[x] += sum[y];</span><br><span class="line">        --cnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxNumEdgesToRemove</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges)</span> </span>&#123;</span><br><span class="line">        Unionset a = <span class="built_in">Unionset</span>();</span><br><span class="line">        Unionset b = <span class="built_in">Unionset</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        a.<span class="built_in">init</span>(n);</span><br><span class="line">        b.<span class="built_in">init</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:edges) --i[<span class="number">1</span>], --i[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">0</span>] == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a.<span class="built_in">Union</span>(i[<span class="number">1</span>], i[<span class="number">2</span>])) ans++;</span><br><span class="line">                <span class="keyword">else</span> b.<span class="built_in">Union</span>(i[<span class="number">1</span>], i[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a.<span class="built_in">Union</span>(i[<span class="number">1</span>], i[<span class="number">2</span>])) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">0</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!b.<span class="built_in">Union</span>(i[<span class="number">1</span>], i[<span class="number">2</span>])) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.cnt != <span class="number">1</span> || b.cnt != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021牛客寒假算法基础集训营1 E.三棱锥之刻</title>
      <link href="/blog/2021/03/22/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51%20E.%E4%B8%89%E6%A3%B1%E9%94%A5%E4%B9%8B%E5%88%BB/"/>
      <url>/blog/2021/03/22/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51%20E.%E4%B8%89%E6%A3%B1%E9%94%A5%E4%B9%8B%E5%88%BB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/9981/E">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛牛站在一个棱长为的正三棱锥内部的中心。（牛牛是不可移动的）<br>（所谓正三棱锥，指六条棱都相等的三棱锥。正三棱锥的中心指到 4 个顶点距离都相等的那个点）<br><img src="https://img-blog.csdnimg.cn/2021021016233988.png?" alt="在这里插入图片描述"></p><p>如上图，$AB=AC=BC=AD=BD=CD=a$，牛牛站在P点，$PA=PB=PC=PD$<br>他拿着一个染色喷雾，可以用来给正三棱锥的内表面染色。<br>已知喷雾能喷洒的距离为。也就是说，三棱锥内表面距离牛牛不超过的点才有可能被染色。牛牛想知道，正三棱锥内表面能被他染色的最大面积是多少？<br>ps：牛牛可看成一个无大小的点。重力对于喷雾的影响忽略不计。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>两个正整数和<br>$1 \leq a, r \leq 1000$</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>染色的最大面积。若你的答案和正确答案误差不超过 $1 \times 10^{-3}$<br> ，则认为你的答案正确。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.73205</span><br></pre></td></tr></table></figure><p>这题就是简单几何，实际上就是球体和三棱锥相交的表面积，粗略画一下图发现很简单，就 $3$ 种情况：</p><ul><li>喷洒距离 $r$ 小于正四面体内接圆的半径，此时答案为 $0$</li><li>喷洒距离 $r$ 小于正四面体外接圆的半径，大于等于内接圆的半径，这种情况有两种可能，一种是整个圆内含于三角形，此时的喷射面积就是四个圆的面积；另一种可能就是圆与三角形相交，下图展示一个面的情况</li><li>喷洒距离 $r$ 大于等于正四面体外接圆的半径，此时答案就是正四面体的表面积</li></ul><p><img src="https://img-blog.csdnimg.cn/20210210164407159.jpg?#pic_center" alt="在这里插入图片描述"><br>显然难点就是算这个相交部分的面积了，相交部分的面积我们就用三角形的面积减去三个类三角形的面积即可，我们可以对一个角进行分析，如下图：<br><img src="https://img-blog.csdnimg.cn/20210210175702766.jpg?#pic_center" alt="在这里插入图片描述"></p><p>类三角形的面积=上三角形的面积-(扇形面积-下三角形的面积)<br>我们设几个参数名：</p><ul><li>相交部分面积 $ans$</li><li>内接圆半径 $mn$</li><li>外接圆半径 $mx$</li><li>下三角形面积 $S1$，底 $A$，高为 $H$，斜边长 $L$</li><li>上三角形面积 $S2$，底 $A$</li><li>扇形面积 $S3$，对应弧长 $l$，圆形角 $\alpha$</li></ul><p>下三角形的斜边长为：</p><script type="math/tex; mode=display">L=\sqrt{r^2-mn^2}</script><p>可以通过反三角函数先算出角 $p$ 的大小：</p><script type="math/tex; mode=display">p=arccos(\frac{\sqrt3*a}{L*6})</script><p>那么：</p><script type="math/tex; mode=display">q=\frac{\pi}{3}-p=\frac{\pi}{3}-arccos(\frac{\sqrt3*a}{L*6})</script><p>那么圆形角 $\alpha$ 为：</p><script type="math/tex; mode=display">\alpha=2*q</script><p>所以弧长既可以计算如下：</p><script type="math/tex; mode=display">l=\alpha *L=2*q*L</script><p>所以扇形面积：</p><script type="math/tex; mode=display">S3=\frac{l*L}{2}=q*L^2=(\frac{\pi}{3}-arccos(\frac{\sqrt3*a}{L*6}))*L^2</script><p>下三角的底 $A$ 为：</p><script type="math/tex; mode=display">A=2*L*sin(q)</script><p>下三角的高 $H$ 为：</p><script type="math/tex; mode=display">H=L*cos(q)</script><p>所以：</p><script type="math/tex; mode=display">S1=\frac{A*H}{2}=L^2*sin(q)*cos(q)</script><p>上三角形是很明显是一个等边三角形，面积为：</p><script type="math/tex; mode=display">S2=\frac{\sqrt 3*A^2}{4}=\sqrt 3*L^2*sin^2(q)</script><p>最后答案就是：</p><script type="math/tex; mode=display">ans=\frac{\sqrt 3*a^2}{4}-3*(S2-(S3-S1))</script><p>那最后的答案就是 $4*ans$，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1)</span></span><br><span class="line"><span class="type">double</span> a, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; r;</span><br><span class="line">    <span class="type">double</span> mx = <span class="built_in">sqrt</span>(<span class="number">6</span>) / <span class="number">4</span> * a, mn = <span class="built_in">sqrt</span>(<span class="number">6</span>) / <span class="number">12</span> * a, mid = <span class="built_in">sqrt</span>(<span class="number">2</span>) / <span class="number">4</span> * a;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; mn) <span class="built_in">printf</span>(<span class="string">&quot;0.00000\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; mid) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.5f\n&quot;</span>, <span class="number">4</span> * PI * (r * r - mn * mn));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; mx) &#123;</span><br><span class="line">        <span class="type">double</span> q = PI / <span class="number">3</span> - <span class="built_in">acos</span>(<span class="built_in">sqrt</span>(<span class="number">3</span>) * a / (<span class="number">6</span> * <span class="built_in">sqrt</span>(r * r - mn * mn)));</span><br><span class="line">        <span class="type">double</span> s1 = (r * r - mn * mn) * <span class="built_in">sin</span>(q) * <span class="built_in">cos</span>(q);</span><br><span class="line">        <span class="type">double</span> s2 = <span class="built_in">sqrt</span>(<span class="number">3</span>) * (r * r - mn * mn) * <span class="built_in">sin</span>(q) * <span class="built_in">sin</span>(q);</span><br><span class="line">        <span class="type">double</span> s3 = q * (r * r - mn * mn);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.5f\n&quot;</span>, <span class="built_in">sqrt</span>(<span class="number">3</span>) * a * a - <span class="number">12</span> * (s1 + s2 - s3));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.5f\n&quot;</span>, <span class="built_in">sqrt</span>(<span class="number">3</span>) * a * a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021牛客寒假算法基础集训营1 C.红和蓝</title>
      <link href="/blog/2021/03/22/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51%20C.%E7%BA%A2%E5%92%8C%E8%93%9D/"/>
      <url>/blog/2021/03/22/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51%20C.%E7%BA%A2%E5%92%8C%E8%93%9D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/9981/C">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你拿到了一棵树，请你给每个顶点染成红色或蓝色。<br>要求：每个红点周围有且仅有一个红点，每个蓝点周围有且仅有一个蓝点。<br>“周围”的定义：某点周围的点指通过邻边直接连接的点。<br>所谓树，即没有自环、重边和回路的无向连通图。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>第一行一个正整数 $n$，代表树的顶点个数。$(1 \leq n \leq 100000)$<br>接下来的 $n-1$ 行，每行两个正整数 $u$ 和 $v$，代表点 $u$ 和点 $v$ 有一条边连接。    $(1 \leq u,v \leq n)$<br>保证输入的一定是一棵合法的树。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>如果可以达成染色的要求，请输出一个长度为 $n$ 的字符串，第  $i$ 个字符代表第  $i$ 个顶点的染色情况，’B’ 代表蓝色，’R’ 代表红色。（若有多种合法染色的方法，输出任意一种即可）<br>否则直接输出 $-1$。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RRBB</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p>题解写得有点复杂，我换种思路，采取自底向上染色的方法，对一个叶子结点来说，显然它只能和其父亲同色，我们就给其一对相同的编号，若遍历一遍树刚好能拆成偶数对，证明可以染色，那再遍历一遍染色即可，编号过程如下图：<br><img src="https://img-blog.csdnimg.cn/20210210155538966.jpg?#pic_center" alt="在这里插入图片描述"><br>若在编号过程中发现某一结点的父亲已经染色，证明其父亲已和其他结点组成一对，那么这个结点必无法染色，则直接输出 $-1$ 即可，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> n, x, y, cnt, id[N] = &#123;<span class="number">1</span>&#125;, ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> son, <span class="type">int</span> father)</span> </span>&#123;<span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> kid:G[son]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (kid != father) <span class="built_in">dfs1</span>(kid, son);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!id[son]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (id[father]) &#123;<span class="comment">//若父亲结点已被编号直接输出-1</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        id[father] = id[son] = ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> son, <span class="type">int</span> father, <span class="type">int</span> color)</span> </span>&#123;<span class="comment">//染色</span></span><br><span class="line">    ans[son] = color;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> kid:G[son]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (kid != father) <span class="built_in">dfs2</span>(kid, son, (id[kid] == id[son] ? color : color ^ <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        G[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">putchar</span>(ans[i] ? <span class="string">&#x27;R&#x27;</span> : <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> 思维 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 959 由斜杠划分区域</title>
      <link href="/blog/2021/03/22/LeetCode%20959%20%E7%94%B1%E6%96%9C%E6%9D%A0%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F/"/>
      <url>/blog/2021/03/22/LeetCode%20959%20%E7%94%B1%E6%96%9C%E6%9D%A0%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/">题目链接</a></p><p>在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\ 或空格构成。这些字符会将方块划分为一些共边的区域。</p><p>（请注意，反斜杠字符是转义的，因此 \ 用 \\ 表示）。</p><p>返回区域的数目。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  &quot; /&quot;,</span><br><span class="line">  &quot;/ &quot;</span><br><span class="line">]</span><br><span class="line">输出：2</span><br><span class="line">解释：2x2 网格如下：</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210210103740946.png" alt="在这里插入图片描述"></p><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  &quot; /&quot;,</span><br><span class="line">  &quot;  &quot;</span><br><span class="line">]</span><br><span class="line">输出：1</span><br><span class="line">解释：2x2 网格如下：</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210210103843524.png" alt="在这里插入图片描述"></p><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  &quot;\\/&quot;,</span><br><span class="line">  &quot;/\\&quot;</span><br><span class="line">]</span><br><span class="line">输出：4</span><br><span class="line">解释：（回想一下，因为 \ 字符是转义的，所以 &quot;\\/&quot; 表示 \/，而 &quot;/\\&quot; 表示 /\。）</span><br><span class="line">2x2 网格如下：</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210210103917399.png" alt="在这里插入图片描述"></p><h2 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  &quot;/\\&quot;,</span><br><span class="line">  &quot;\\/&quot;</span><br><span class="line">]</span><br><span class="line">输出：5</span><br><span class="line">解释：（回想一下，因为 \ 字符是转义的，所以 &quot;/\\&quot; 表示 /\，而 &quot;\\/&quot; 表示 \/。）</span><br><span class="line">2x2 网格如下：</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210210103930182.png" alt="在这里插入图片描述"></p><h2 id="示例-5："><a href="#示例-5：" class="headerlink" title="示例 5："></a>示例 5：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  <span class="string">&quot;//&quot;</span>,</span><br><span class="line">  <span class="string">&quot;/ &quot;</span></span><br><span class="line">]</span><br><span class="line">输出：3</span><br><span class="line">解释：2x2 网格如下：</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210210103945966.png" alt="在这里插入图片描述"></p><p>思维+并查集~<br>我们可以将一格分成四块，那么对每一格的划分就有下面三张情况，合并对应的编号即可：<br><img src="https://img-blog.csdnimg.cn/20210210104013151.png?" alt="在这里插入图片描述"><br>对每一个大格，只有两种相邻情况，合并相应的编号即可：<br><img src="https://img-blog.csdnimg.cn/20210210104200698.png" alt="在这里插入图片描述"><br>最后返回连通块的数目即可~<br>离散化处理：初始化连通块数目置为 $4<em>N</em>N$，将二维坐标离散成一维，$(x,y)-&gt;4<em>(x</em>N+y)$<br>AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Unionset</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; father;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sum;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        father.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) father[i] = i;</span><br><span class="line">        sum.<span class="built_in">resize</span>(n);</span><br><span class="line">        cnt = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findFather</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == father[x] ? x : father[x] = <span class="built_in">findFather</span>(father[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">findFather</span>(x), y = <span class="built_in">findFather</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum[x] &lt; sum[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        father[y] = x;</span><br><span class="line">        sum[x] += sum[y];</span><br><span class="line">        --cnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">regionsBySlashes</span><span class="params">(vector&lt;string&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> N = grid.<span class="built_in">size</span>();</span><br><span class="line">        Unionset u = <span class="built_in">Unionset</span>();</span><br><span class="line">        u.<span class="built_in">init</span>(<span class="number">4</span> * N * N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="type">int</span> id = <span class="number">4</span> * (i * N + j);</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    u.<span class="built_in">Union</span>(id, id + <span class="number">3</span>);</span><br><span class="line">                    u.<span class="built_in">Union</span>(id + <span class="number">1</span>, id + <span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;\\&#x27;</span>) &#123;</span><br><span class="line">                    u.<span class="built_in">Union</span>(id, id + <span class="number">1</span>);</span><br><span class="line">                    u.<span class="built_in">Union</span>(id + <span class="number">2</span>, id + <span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    u.<span class="built_in">Union</span>(id, id + <span class="number">1</span>);</span><br><span class="line">                    u.<span class="built_in">Union</span>(id + <span class="number">1</span>, id + <span class="number">2</span>);</span><br><span class="line">                    u.<span class="built_in">Union</span>(id + <span class="number">2</span>, id + <span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; N) &#123;</span><br><span class="line">                    u.<span class="built_in">Union</span>(id + <span class="number">2</span>, <span class="number">4</span> * ((i + <span class="number">1</span>) * N + j));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; N) &#123;</span><br><span class="line">                    u.<span class="built_in">Union</span>(id + <span class="number">1</span>, <span class="number">4</span> * (i * N + j + <span class="number">1</span>) + <span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python小项目——生成个性二维码</title>
      <link href="/blog/2021/03/22/Python%E5%B0%8F%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E4%B8%AA%E6%80%A7%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
      <url>/blog/2021/03/22/Python%E5%B0%8F%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E4%B8%AA%E6%80%A7%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>现代社交离不开微信，<font face="Consolas">QQ，那么今天就教你用 <font face="Consolas">Python 生成自己的个性二维码😎<br>这里用到了 MyQR 库，下面是 github 的地址：<br>[<font face="Consolas">MyQR</font>](<a href="https://github.com/qiulongquan/MyQR">https://github.com/qiulongquan/MyQR</a>)<br>官方介绍：<br>制作普通二维码、带有图片的艺术二维码和动态二维码。这个库可以直接在 <font face="Consolas">Pycharm 的 Settings 的 Project interpreter 里点 + 号下载，也可以在 cmd 里用 <font face="Consolas">pip 命令安装。<br>下载完后导包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> MyQR <span class="keyword">import</span> myqr</span><br></pre></td></tr></table></figure><p>下面就让我们来看看里面最主要的 <font face="Consolas">run 函数，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">words, version=<span class="number">1</span>, level=<span class="string">&#x27;H&#x27;</span>, picture=<span class="literal">None</span>, colorized=<span class="literal">False</span>, contrast=<span class="number">1.0</span>, brightness=<span class="number">1.0</span>, save_name=<span class="literal">None</span>, save_dir=os.getcwd(<span class="params"></span>)</span>):</span><br></pre></td></tr></table></figure><h2 id="words"><a href="#words" class="headerlink" title="words"></a><font face="Consolas">words</h2><p><font face="Consolas">words</font> 里面放的就是二维码的内容，举个例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myqr.run(words=<span class="string">&#x27;i love you&#x27;</span>)</span><br></pre></td></tr></table></figure><p>生成如下二维码：<br><img src="https://img-blog.csdnimg.cn/20210209120917966.png#pic_center" alt="在这里插入图片描述">扫码就会出现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i love you</span><br></pre></td></tr></table></figure><p>当然 <font face="Consolas">words</font> 里面也可以放地址，比如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myqr.run(words=<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure><p>生成如下图片：<br><img src="https://img-blog.csdnimg.cn/20210209121913666.png#pic_center" alt="在这里插入图片描述"><br>扫码就能直接进入百度界面~<br>那么如何添加我们个人的二维码呢？我们只需要将我们的QQ或者微信二维码解析一下 <a href="https://cli.im/deqr">草料二维码(将二维码图片上传解码)</a> 得到地址，下面是我解析我的QQ二维码获得的地址，并用该地址生成了二维码(有人可能会问，我用二维码图片再生成二维码图片，我是不是脑子有问题😒，别急，下面教你把二维码跟图片结合)：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myqr.run(words=<span class="string">&#x27;https://qm.qq.com/cgi-bin/qm/qr?k=l-4r-RKlP8E1nGoHSWUzNvUPR6w6p5eK&amp;noverify=0&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210209121659329.png#pic_center" alt="在这里插入图片描述"></p><h2 id="picture"><a href="#picture" class="headerlink" title="picture"></a><font face="Consolas">picture</font></h2><p>这是比较强大的一个地方，可以将二维码和图片结合，注意如果图片不是和 py 文件在同一目录下会报错，这次我用下图和上述的QQ二维码解码地址结合：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myqr.run(words=<span class="string">&#x27;https://qm.qq.com/cgi-bin/qm/qr?k=l-4r-RKlP8E1nGoHSWUzNvUPR6w6p5eK&amp;noverify=0&#x27;</span>,</span><br><span class="line">         picture=<span class="string">&#x27;1.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210209135907655.jpg#pic_center" alt="在这里插入图片描述"><br>效果如下：<br><img src="https://img-blog.csdnimg.cn/20210209135937543.png?#pic_center" alt="在这里插入图片描述"><br>不难发现这是黑白的，明显更丑了，所以我们用到了下面第三个参数😀</p><h2 id="colorized"><a href="#colorized" class="headerlink" title="colorized"></a><font face="Consolas">colorized</font></h2><p><font face="Consolas">bool</font> 类型，设置为 <font face="Consolas">True</font> 时即可看到彩色的二维码图片了，还是用上面的图片举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myqr.<span class="built_in">run</span>(words=<span class="string">&#x27;https://qm.qq.com/cgi-bin/qm/qr?k=l-4r-RKlP8E1nGoHSWUzNvUPR6w6p5eK&amp;noverify=0&#x27;</span>,</span><br><span class="line">         colorized=True,</span><br><span class="line">         picture=<span class="string">&#x27;1.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210209140751419.png?#pic_center" alt="在这里插入图片描述"><br>这效果不就来了，你们找喜欢的图片与二维码结合即可~<br>下面介绍一下这个函数非常强大的一个功能：动态二维码</p><h2 id="动态二维码"><a href="#动态二维码" class="headerlink" title="动态二维码"></a>动态二维码</h2><p><font face="Consolas">picture</font> 不仅能放静图，还能放 <font face="Consolas">GIF</font> 动图，比如我用下面这张图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myqr.run(words=<span class="string">&#x27;https://qm.qq.com/cgi-bin/qm/qr?k=l-4r-RKlP8E1nGoHSWUzNvUPR6w6p5eK&amp;noverify=0&#x27;</span>,</span><br><span class="line">         colorized=<span class="literal">True</span>,</span><br><span class="line">         picture=<span class="string">&#x27;1.gif&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210209141326715.gif#pic_center" alt="在这里插入图片描述"><br>效果如下：<br><img src="https://img-blog.csdnimg.cn/20210209141504720.gif#pic_center" alt="在这里插入图片描述"><br>学到这里你就掌握了生成个性二维码的诀窍了，是不是很简单，不仅微信和QQ可以，你们同样可以给自己的网站(博客，微博，gihub)等生成个性二维码，下面再补充一个小点</p><h2 id="save-name"><a href="#save-name" class="headerlink" title="save_name"></a><font face="Consolas">save_name</h2><p>设置生成图片的名字和格式，比如可以把 <font face="Consolas">JPG 格式的可以保存成 <font face="Consolas">PNG 格式的图片，保存的位置和 <font face="Consolas">py文件同一目录，下面挂一段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> MyQR <span class="keyword">import</span> myqr</span><br><span class="line">myqr.run(</span><br><span class="line">    words=<span class="string">&#x27;https://u.wechat.com/MHPhZxXSgAvAzy_oDqCUPkg&#x27;</span>,</span><br><span class="line">    picture=<span class="string">&#x27;1.jpg&#x27;</span>,</span><br><span class="line">    colorized=<span class="literal">True</span>,</span><br><span class="line">    save_name=<span class="string">&#x27;zaizai.png&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>学到这里就结束啦，快去试试生成你自己的个性二维码吧！😁</p>]]></content>
      
      
      <categories>
          
          <category> Python小项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1489 找到最小生成树里的关键边和伪关键边</title>
      <link href="/blog/2021/03/22/LeetCode%201489%20%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%87%8C%E7%9A%84%E5%85%B3%E9%94%AE%E8%BE%B9%E5%92%8C%E4%BC%AA%E5%85%B3%E9%94%AE%E8%BE%B9/"/>
      <url>/blog/2021/03/22/LeetCode%201489%20%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%87%8C%E7%9A%84%E5%85%B3%E9%94%AE%E8%BE%B9%E5%92%8C%E4%BC%AA%E5%85%B3%E9%94%AE%E8%BE%B9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/">题目描述</a></p><p>给你一个 $n$ 个点的带权无向连通图，节点编号为 $0$ 到 $n-1$ ，同时还有一个数组 $edges$ ，其中 $edges[i] = [from_i, to_i, weight_i]$ 表示在 $from_i$ 和 $to_i$ 节点之间有一条带权无向边。最小生成树 (MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。</p><p>请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。</p><p>请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><p><img src="https://img-blog.csdnimg.cn/20210209110503489.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]</span><br><span class="line">输出：[[0,1],[2,3,4,5]]</span><br><span class="line">解释：上图描述了给定图。</span><br><span class="line">下图是所有的最小生成树。</span><br><span class="line">注意到第 0 条边和第 1 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。</span><br><span class="line">边 2，3，4 和 5 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021020911051727.png" alt="在这里插入图片描述"></p><h2 id="示例-2-："><a href="#示例-2-：" class="headerlink" title="示例 2 ："></a>示例 2 ：</h2><p><img src="https://img-blog.csdnimg.cn/20210209110547569.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]</span><br><span class="line">输出：[[],[0,1,2,3]]</span><br><span class="line">解释：可以观察到 4 条边都有相同的权值，任选它们中的 3 条可以形成一棵 MST 。所以 4 条边都是伪关键边。</span><br></pre></td></tr></table></figure><p>这题的关键是找边，所以只能用最小生成树的 Kruskal 算法。<br>我们先给所有边编号，先求一遍最小生成树的权值和 $value$，然后依次遍历所有边 $i$，先算去掉边 $i$ 的最小生成树的权值和 $v$，若此时无法构造最小生成树或者 $v&gt;value$，则这条边一定是关键边；再算伪关键边，我们加上这条边的权值，再算一次最小生成树的权值和 $v$，若 $v=value$，证明该边没有出现在所有的最小生成树中，一定是伪关键边，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Unionset</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; father;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sum;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        father.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) father[i] = i;</span><br><span class="line">        sum.<span class="built_in">resize</span>(n);</span><br><span class="line">        cnt = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findFather</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == father[x] ? x : father[x] = <span class="built_in">findFather</span>(father[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">findFather</span>(x), y = <span class="built_in">findFather</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum[x] &lt; sum[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        father[y] = x;</span><br><span class="line">        sum[x] += sum[y];</span><br><span class="line">        --cnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findCriticalAndPseudoCriticalEdges</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges) &#123;</span><br><span class="line">        <span class="type">int</span> m = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) edges[i].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span> &amp;u, <span class="type">const</span> <span class="keyword">auto</span> &amp;v) &#123; <span class="keyword">return</span> u[<span class="number">2</span>] &lt; v[<span class="number">2</span>]; &#125;);</span><br><span class="line">        <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">        Unionset a = <span class="built_in">Unionset</span>();</span><br><span class="line">        a.<span class="built_in">init</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i:edges) <span class="keyword">if</span> (a.<span class="built_in">Union</span>(i[<span class="number">0</span>], i[<span class="number">1</span>])) value += i[<span class="number">2</span>];</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Unionset b = <span class="built_in">Unionset</span>();</span><br><span class="line">            b.<span class="built_in">init</span>(n);</span><br><span class="line">            <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j &amp;&amp; b.<span class="built_in">Union</span>(edges[j][<span class="number">0</span>], edges[j][<span class="number">1</span>])) v += edges[j][<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.cnt != <span class="number">1</span> || (b.cnt == <span class="number">1</span> &amp;&amp; v &gt; value)) &#123;</span><br><span class="line">                ans[<span class="number">0</span>].<span class="built_in">emplace_back</span>(edges[i][<span class="number">3</span>]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Unionset c = <span class="built_in">Unionset</span>();</span><br><span class="line">            c.<span class="built_in">init</span>(n);</span><br><span class="line">            c.<span class="built_in">Union</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">            v = edges[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j &amp;&amp; c.<span class="built_in">Union</span>(edges[j][<span class="number">0</span>], edges[j][<span class="number">1</span>])) v += edges[j][<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v == value) ans[<span class="number">1</span>].<span class="built_in">push_back</span>(edges[i][<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021牛客寒假算法基础集训营2 F.牛牛与交换排序</title>
      <link href="/blog/2021/03/22/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A52%20F.%E7%89%9B%E7%89%9B%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
      <url>/blog/2021/03/22/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A52%20F.%E7%89%9B%E7%89%9B%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/9982/F">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛牛有一个数组，数组元素是 $1$ 到 $n$ 的排列，即数组的值在 $1\sim n$ 范围内，且每个数字仅出现 $1$ 次。<br>牛牛想要将该数组变为升序排列的，他可以进行如下的操作。</p><p>首先他要确定一个长度 $k$，$k$ 的范围在 $1\sim n$ 之间。<br>接下来他将会进行若干次操作。在每轮操作中他都可以选择一段长度为k的子数组，然后进行区间的翻转操作。</p><p>他可以做任意次数的操作，但是要求他每次选择的子数组区间满足 $l<em>i \leq l</em>{i+1}$，并且区间长度等于一开始选定的 $k$，也就是说一旦某一次操作选择了数组的某个位置进行区间翻转操作，下一次做区间翻转的位置将会比上一次更靠右。</p><p>牛牛发现，并不总是存在一个 $k$ 可以使得数组排序变为有序，请你告诉牛牛是否存在一个 $k$ 能够在满足规则的情况下完成排序。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>第一行输入一个正整数 $n(1 \leq n \leq 10^5)$ 表示数组的大小。<br>接下来输出一行 $n$ 个正整数表示一个排列，即每个数的大小范围在 $1$ 到 $n$ 且每个正整数仅出现一次。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>如果存在至少一个 $k$ 能够使牛牛完成排序，请先在一行中输出一个 “yes”，然后另起一行输出一个可以满足排序的k，要求k的范围在 $\left[ 1,n \right]$ 之间，如果有多解，你可以输出任意一个。</p><p>反之如果不存在任何一个k可以完成排序，请直接在一行输出一个 “no”</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">5 2 1 4 3</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yes</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yes</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yes</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>思维+模拟~<br>因为每次区间的选择都只能往右走，也就是对某一位置 $i$，若它的 $pos[i]$(它在所给数组中的位置)在右边，那么必须只能一次操作将其换回原位，也就是说我们只要找到第一个不在原位置的 $i$，那么 $k$ 一定就是 $pos[i]-i+1$~<br>找到该位置后我们就要去想用什么数据结构能模拟一次排序数组的过程，显然这个数据要能从头取，也能从尾取，所以很容易想到双端队列，对翻转这个操作我们通常的技巧就是设置一个翻转标记，而不需要真的把队列翻转，例如原本翻转标记 $flag=0$，我们这是从队头弹出，队尾插入，翻转后只需要从队尾弹出，队头插入即可，STL 里面就有 $deque$ 这个数据结构，不熟悉的同学可以去自学一下~<br>整个模拟过程简单描述如下：</p><ul><li>先存 $k$ 个元素</li><li>每次拿位置 $i$ 和队头队尾进行匹配，匹配成功执行相应的弹出插入操作和修改对应的翻转标记，不匹配直接输出 $no$ 即可</li></ul><p>AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, k, flag = <span class="number">0</span>, a[N], pos[N];</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        pos[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos[i] != i) &#123;</span><br><span class="line">            k = pos[i] - i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!k) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes\n&quot;</span> &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) q.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt;= n + k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(flag % <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - k == q.<span class="built_in">front</span>()) q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i - k == q.<span class="built_in">back</span>()) flag ^= <span class="number">1</span>, q.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;no&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag % <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - k == q.<span class="built_in">back</span>()) q.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i - k == q.<span class="built_in">front</span>()) flag ^= <span class="number">1</span>, q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;no&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag % <span class="number">2</span>) q.<span class="built_in">push_front</span>(a[i]);</span><br><span class="line">            <span class="keyword">else</span> q.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;yes\n&quot;</span> &lt;&lt; k;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> deque </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1712 将数组分成三个子数组的方案数</title>
      <link href="/blog/2021/03/22/LeetCode%201712%20%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E4%B8%89%E4%B8%AA%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/"/>
      <url>/blog/2021/03/22/LeetCode%201712%20%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E4%B8%89%E4%B8%AA%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/ways-to-split-array-into-three-subarrays/">题目链接</a></p><p>我们称一个分割整数数组的方案是 好的 ，当它满足：</p><p>数组被分成三个 非空 连续子数组，从左至右分别命名为 left ， mid ， right 。<br>left 中元素和小于等于 mid 中元素和，mid 中元素和小于等于 right 中元素和。<br>给你一个 非负 整数数组 nums ，请你返回 好的 分割 nums 方案数目。由于答案可能会很大，请你将结果对 $10^9+7$ 取余后返回。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：唯一一种好的分割方案是将 nums 分成 [1] [1] [1] 。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,2,2,5,0]</span><br><span class="line">输出：3</span><br><span class="line">解释：nums 总共有 3 种好的分割方案：</span><br><span class="line">[1] [2] [2,2,5,0]</span><br><span class="line">[1] [2,2] [2,5,0]</span><br><span class="line">[1,2] [2,2] [5,0]</span><br></pre></td></tr></table></figure><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：没有好的分割方案。</span><br></pre></td></tr></table></figure><p>题意比较简单，就是往一个数组里插两块隔板，暴力的话复杂度 $O(n^2)$，显然不行，考虑优化，很容易想到二分，遍历第一块隔板的位置 $i$，然后找第二块隔板的所有合法位置区间 $[L,R]$ 即可，预处理所有数的前缀和，左端点 $L$ 可以通过一个 $lower_bound$ 直接求得，而对右端点 $R$，直接二分求即可，对每一块隔板 $i$，答案加上 $R-L+1$，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> pre[<span class="number">100005</span>] = &#123;<span class="number">0</span>&#125;, ans = <span class="number">0</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>, len;</span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; v;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (pre[len - <span class="number">1</span>] - pre[mid] &gt;= pre[mid] - pre[p]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">waysToSplit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) pre[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> pre[i] = pre[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">            v.<span class="built_in">push_back</span>(pre[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> pos1 = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>() + i + <span class="number">1</span>, v.<span class="built_in">end</span>(), pre[i] + pre[i]) - v.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span> (pos1 == v.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> pos2 = <span class="built_in">bs</span>(pos1, len - <span class="number">2</span>, i);</span><br><span class="line">            ans = (ans + (<span class="type">long</span> <span class="type">long</span>) (pos2 - pos1 + <span class="number">1</span>)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 644 (Div. 3) H.Binary Median</title>
      <link href="/blog/2021/03/22/Codeforces%20Round%20644%20(Div.%203)%20H.Binary%20Median/"/>
      <url>/blog/2021/03/22/Codeforces%20Round%20644%20(Div.%203)%20H.Binary%20Median/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.ml/problemset/problem/1360/H">题目链接</a></p><p><font face="consolas">Consider all binary strings of length m (1≤m≤60). A binary string is a string that consists of the characters 0 and 1 only. For example, 0110 is a binary string, and 012aba is not. Obviously, there are exactly 2m such strings in total.</p><p><font face="consolas">The string s is lexicographically smaller than the string t (both have the same length m) if in the first position i from the left in which they differ, we have s[i]&lt;t[i]. This is exactly the way strings are compared in dictionaries and in most modern programming languages when comparing them in a standard way. For example, the string 01011 is lexicographically smaller than the string 01100, because the first two characters are the same, and the third character in the first string is less than that in the second.</p><p><font face="consolas">We remove from this set $n (1≤n≤min(2^{m−1},100))$ distinct binary strings a1,a2,…,an, each of length m. Thus, the set will have k=2m−n strings. Sort all strings of the resulting set in lexicographical ascending order (as in the dictionary).</p><p><font face="consolas">We number all the strings after sorting from 0 to k−1. Print the string whose index is ⌊k−1⌋/2 (such an element is called median), where ⌊x⌋ is the rounding of the number down to the nearest integer.</p><p><font face="consolas">For example, if n=3, m=3 and a=[010, 111, 001], then after removing the strings ai and sorting, the result will take the form: [000, 011, 100, 101, 110]. Thus, the desired median is 100.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><font face="consolas">Input</h2><p><font face="consolas">The first line contains an integer t (1≤t≤1000) — the number of test cases. Then, t test cases follow.</p><p><font face="consolas">The first line of each test case contains integers $n (1≤n≤min(2^{m−1},100))$ and m (1≤m≤60), where n is the number of strings to remove, and m is the length of binary strings. The next n lines contain a1,a2,…,an — distinct binary strings of length m.</p><p><font face="consolas">The total length of all given binary strings in all test cases in one test does not exceed $10^5$.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a><font face="consolas">Output</h2><p><font face="consolas">Print t answers to the test cases. For each test case, print a string of length m — the median of the sorted sequence of remaining strings in the corresponding test case.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a><font face="consolas">Example</h2><h3 id="input"><a href="#input" class="headerlink" title="input"></a><font face="consolas">input</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 3</span><br><span class="line">010</span><br><span class="line">001</span><br><span class="line">111</span><br><span class="line">4 3</span><br><span class="line">000</span><br><span class="line">111</span><br><span class="line">100</span><br><span class="line">011</span><br><span class="line">1 1</span><br><span class="line">1</span><br><span class="line">1 1</span><br><span class="line">0</span><br><span class="line">3 2</span><br><span class="line">00</span><br><span class="line">01</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="output"><a href="#output" class="headerlink" title="output"></a><font face="consolas">output</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">010</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p>这题用到了位运算，我们把所有二进制字符串转化为十进制存入数组 $a$，考虑到内存限制，$bitset$ 恰好完美地解决了这个问题，我们先定位要找的那个数的位置 $pos$，也即十进制里面的大小，然后遍历数组 $a$，如果有数小于等于 $pos$，则 $pos+1$，最后再将其转化为二进制输出即可，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll a[n];</span><br><span class="line">    string s;</span><br><span class="line">    ll ans = ((<span class="number">1LL</span> &lt;&lt; m) - n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        a[i] = <span class="built_in">bitset</span>&lt;<span class="number">64</span>&gt;(s).<span class="built_in">to_ullong</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i:a) ans += (i &lt;= ans);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">64</span>&gt;(ans).<span class="built_in">to_string</span>().<span class="built_in">substr</span>(<span class="number">64</span> - m) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> bitset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛75 A.广义肥波</title>
      <link href="/blog/2021/03/22/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B75%20A.%E5%B9%BF%E4%B9%89%E8%82%A5%E6%B3%A2/"/>
      <url>/blog/2021/03/22/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B75%20A.%E5%B9%BF%E4%B9%89%E8%82%A5%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/10507/A">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>广义肥波那契数列，以递归的方法定义如下：</p><p>$\begin{cases}f<em>1=1\f_2=1\f_n=a\cdot f</em>{n-1}+b\cdot f_{n-2}(n\ge 3, n\in \mathbb Z)\end{cases}$</p><p>例如，当 $a=b=\text 1$ 时，数列为 $[\text 1,1,2,3,5,8,13,…]$。<br>现在，请求出 $m^{f_n}$。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>输入共一行,包含 $\text 4$ 个正整数 $a,b,m,n(1\le a,b,m\le 10^9,1\le n \le 10^5)$</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>输出共一行，包含一个非负整数表示答案。由于结果可能较大，你只需要输出答案对 $10^9+7=1,000,000,007$ 取模的结果。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 4</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><p>求斐波那契数列就是简单的矩阵快速幂了，但是题目设了一个小坑，就是 $a^b\% mod$，显然你的幂数和底数的模数是不一样的，而 $mod=10^9+7$，模数恰为素数，所以根据欧拉降幂，$a^b\%mod=a^{b\%(mod-1)}\% mod$，很多人可能意识到了矩阵快速幂，但是忽略了这个，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>, n, K, A, B, m, mod1 = <span class="number">1e9</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">power</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">power</span>(a * a % mod, b / <span class="number">2</span>) * (b % <span class="number">2</span> ? a : <span class="number">1</span>) % mod : <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span> &#123;</span><br><span class="line">    ll m[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">mul</span><span class="params">(mat a, mat b)</span> </span>&#123;</span><br><span class="line">    mat c;</span><br><span class="line">    <span class="built_in">memset</span>(c.m, <span class="number">0</span>, <span class="built_in">sizeof</span>(c.m));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.m[i][k] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]) % mod1;</span><br><span class="line">                <span class="keyword">if</span> (c.m[i][j] &lt; <span class="number">0</span>) c.m[i][j] += mod1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">mat_pow</span><span class="params">(mat a, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    mat ans;</span><br><span class="line">    ans.m[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, ans.m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    ans.m[<span class="number">0</span>][<span class="number">1</span>] = ans.m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ans = <span class="built_in">mul</span>(a, ans);</span><br><span class="line">        a = <span class="built_in">mul</span>(a, a);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="number">2</span>;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B &gt;&gt; m &gt;&gt; K;</span><br><span class="line">    mat a;</span><br><span class="line">    a.m[<span class="number">0</span>][<span class="number">0</span>] = A, a.m[<span class="number">0</span>][<span class="number">1</span>] = B;</span><br><span class="line">    a.m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>, a.m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (K &lt;= <span class="number">2</span>) cout &lt;&lt; m;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mat ans = <span class="built_in">mat_pow</span>(a, K - <span class="number">2</span>);</span><br><span class="line">        ll u = ans.m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        cout &lt;&lt; <span class="built_in">power</span>(m, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> 矩阵快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021牛客寒假算法基础集训营2 I.牛牛的“质因数”</title>
      <link href="/blog/2021/03/22/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A52%20I.%E7%89%9B%E7%89%9B%E7%9A%84%E2%80%9C%E8%B4%A8%E5%9B%A0%E6%95%B0%E2%80%9D/"/>
      <url>/blog/2021/03/22/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A52%20I.%E7%89%9B%E7%89%9B%E7%9A%84%E2%80%9C%E8%B4%A8%E5%9B%A0%E6%95%B0%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/9982/I">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>算数基本定理，又称唯一分解定理，算术基本定理可表述为：任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积。即 $N=p_1^{e_1}\cdot p_2^{e_2}…p_m^{e_m}(p_1 &lt; p_2&lt; … p_m)$ 朴素的质因子分解算法就是利用了算数基本定理，依次枚举 $p$ 判断N是否包含素因子 $p$。</p><p>牛牛最近对于质因数分解产生了浓厚的兴趣。</p><p>牛牛定义了一个函数 $F(x)$，它表示将 $x$ 做质因数分解后得到的数字从小到大升序排列，然后将其“拼接”成一个大整数。<br>例如 $1500=2<em>2</em>3<em>5</em>5*5,F(1500)=223555$。<br>牛牛现在想要知道 $\sum_{i=2}^{n}F(i)$ 的值。</p><p>由于这个结果非常大，所以你只用告诉牛牛最终答案对 $10^9+7$ 取余数的结果即可。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>仅一行一个正整数 $n(2 \leq n \leq 4 \times 10^6)$</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>仅一行，表示答案对 $10^9+7$ 取余数的结果。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">342</span><br></pre></td></tr></table></figure><p>一开始就想着暴力算，素筛+质因子分解，这样写跑 $4e6$ 本地要 $3$ 秒，自闭了一会儿我就去忙别的了，最后一个小时突然觉悟了，为什么不记忆化一下每一次算得的答案呢，比如我们暴力算 $20$ 的时候，要算出它所有的质因子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 2 5</span><br></pre></td></tr></table></figure><p>而记忆化的时候我们只需要算 $2*10^{cnt[ans[10]]}+ans[10]$ 即可，什么意思呢？我们记忆化的时候存两个值，一个是 $ans$ (记录某个数算得的答案)，一个是 $cnt$ (记录某个数答案的位数)，我们只需要遍历一遍 $n$ 直接算出所有答案即可，递推公式如下:</p><script type="math/tex; mode=display">ans[i*j]=\begin{cases}ans[i]*10^{cnt[j]}+ans[j],i<j\\ans[j]*10^{cnt[i]}+ans[i],i\geq j\end{cases}</script><p>为了方便计算我还是选了素筛，把 $j$ 替换成了素数，这样复杂度就是线性筛+一次遍历，一共 $O(2<em>N)$，上面公式直接算也可以，复杂度稍高，应该是 $O(N</em>logN)$，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll N = <span class="number">4e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll n, k, sum, prime[N / <span class="number">10</span>], cnt[N], ans[N], vis, p10[<span class="number">1000</span>];</span><br><span class="line"><span class="type">bool</span> isprime[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(isprime, isprime + N, <span class="number">1</span>);</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isprime[i]) &#123;</span><br><span class="line">            prime[k++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime[j] &gt; N) <span class="keyword">break</span>;</span><br><span class="line">            isprime[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p10[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++) p10[i] = <span class="number">10</span> * p10[i - <span class="number">1</span>] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">Prime</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime[j] &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                ans[prime[j]] = prime[j] % mod;</span><br><span class="line">                cnt[prime[j]] = <span class="built_in">f</span>(prime[j]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[i * prime[j]] = cnt[i] + cnt[prime[j]];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; prime[j]) &#123;</span><br><span class="line">                ans[i * prime[j]] = (ans[i] * p10[cnt[prime[j]]] % mod + ans[prime[j]] % mod) % mod;</span><br><span class="line">            &#125; <span class="keyword">else</span> ans[i * prime[j]] = (ans[prime[j]] * p10[cnt[i]] % mod + ans[i] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum = (sum + ans[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> 素筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021牛客寒假算法基础集训营1 I.限制不互素对的排列</title>
      <link href="/blog/2021/03/22/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51%20I.%E9%99%90%E5%88%B6%E4%B8%8D%E4%BA%92%E7%B4%A0%E5%AF%B9%E7%9A%84%E6%8E%92%E5%88%97/"/>
      <url>/blog/2021/03/22/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51%20I.%E9%99%90%E5%88%B6%E4%B8%8D%E4%BA%92%E7%B4%A0%E5%AF%B9%E7%9A%84%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/9981/I">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个数 $n$，请构造一个长度为 $n$ 的排列，使得其中正好有 $k$ 对相邻的数 $gcd$（最大公约数）大于 $1$ 。<br>排列是指 $1$ 到 $n$ 一共 $n$ 个数，每个数都出现过且仅出现过 $1$ 次。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>两个整数 $n$ 和 $k$，用空格隔开。<br>$2\leq n\leq 100000,0\leq k \leq n/2$</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>如果不存在可行的构造方案，输出 $-1$。<br>否则输出一行 $n$ 个数，用空格隔开。如果有多组可行的构造方案，输出任意一组即可。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 3 6 2 4 1</span><br></pre></td></tr></table></figure><p>题目限制了 $k\leq n/2$，这点非常关键，我就是没有意识到这一点卡了很久~<br>我们发现 $1-n$ 之间的偶数恰好是 $\frac{n}{2}$ 个，所以我们只需要排列这些偶数就能获得 $\frac{n}{2}-1$ 对，那么离最大目标还差一个，我们只需要抽一个 $6$ 出来和 $3$ 拼在一起就行，剩下的数按顺序输出即可，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">6</span> &amp;&amp; k == n / <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) <span class="keyword">if</span> (i != <span class="number">6</span>) v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++) cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>, s.<span class="built_in">insert</span>(v[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!s.<span class="built_in">count</span>(i)) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1802 有界数组中指定下标处的最大值</title>
      <link href="/blog/2021/03/22/LeetCode%201802%20%E6%9C%89%E7%95%8C%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E4%B8%8B%E6%A0%87%E5%A4%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/blog/2021/03/22/LeetCode%201802%20%E6%9C%89%E7%95%8C%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E4%B8%8B%E6%A0%87%E5%A4%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/">题目链接</a></p><p><font face="Consolas">给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：</p><ul><li><font face="Consolas">nums.length == n</li><li><font face="Consolas">nums[i] 是 正整数 ，其中 0 &lt;= i &lt; n</li><li><font face="Consolas">abs(nums[i] - nums[i+1]) &lt;= 1 ，其中 0 &lt;= i &lt; n-1</li><li><font face="Consolas">nums 中所有元素之和不超过 maxSum</li><li><font face="Consolas">nums[index] 的值被最大化</li></ul><p>返回你所构造的数组中的 nums[index] 。</p><p><font face="Consolas">注意：abs(x) 等于 x 的前提是 x &gt;= 0 ；否则，abs(x) 等于 -x 。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, index = 2,  maxSum = 6</span><br><span class="line">输出：2</span><br><span class="line">解释：数组 [1,1,2,1] 和 [1,2,2,1] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 6, index = 1,  maxSum = 10</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><font face="Consolas">一开始以为是找规律，还打表找了半天的规律，后来转念一想发现这不就是二分吗，我们只需要二分那个最大值，从它的下标往两边值递减即可，注意值最小是 1，另外对数列求和会爆 int，所以二分判断到时候要用 longlong，AC 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y, <span class="type">long</span> <span class="type">long</span> z, <span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num1 = y, num2 = n - y - <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1 &gt;= x - <span class="number">1</span>) &#123;</span><br><span class="line">            sum1 = (x - <span class="number">1</span>) * x / <span class="number">2</span> + num1 - (x - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum1 = num1 * (x - num1 + x - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num2 &gt;= x - <span class="number">1</span>) &#123;</span><br><span class="line">            sum2 = (x - <span class="number">1</span>) * x / <span class="number">2</span> + num2 - (x - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum2 = num2 * (x - num2 + x - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum1 + sum2 + x &lt;= z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> index, <span class="type">int</span> maxSum)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = maxSum;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid, index, maxSum, n)) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 二分 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十八届浙大城市学院程序设计竞赛（同步赛） F.Palindrome</title>
      <link href="/blog/2021/03/21/%E7%AC%AC%E5%8D%81%E5%85%AB%E5%B1%8A%E6%B5%99%E5%A4%A7%E5%9F%8E%E5%B8%82%E5%AD%A6%E9%99%A2%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%EF%BC%88%E5%90%8C%E6%AD%A5%E8%B5%9B%EF%BC%89%20F.Palindrome/"/>
      <url>/blog/2021/03/21/%E7%AC%AC%E5%8D%81%E5%85%AB%E5%B1%8A%E6%B5%99%E5%A4%A7%E5%9F%8E%E5%B8%82%E5%AD%A6%E9%99%A2%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%EF%BC%88%E5%90%8C%E6%AD%A5%E8%B5%9B%EF%BC%89%20F.Palindrome/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/12986/F">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><font face="Consolas">You are given a string $s<em>{}$​ of $n</em>{}$ lowercase letters.<br>You have to delete exactly two letters from $s<em>{}$, determine whether the string can become a palindrome after the change.<br>Definition of palindrome: If a string $s</em>{}$ of $n<em>{}$ lowercase letters is a palindrome, then for each $s_i(1\leq i\leq n),s_i=s</em>{n-i+1}$ .<br>For example, “ababa” and “abba” are palindromes, but “abab” not.</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p><font face="Consolas">The first line contains an integer $t(1\leq t\leq10^3)$ — the number of test cases.<br>For each test case, the first line contains an integer $n(3\leq n\leq 2!\cdot!10^3)$  representing the length of $s<em>{}$, the second line contains a string of length $n</em>{}$.<br>It is guaranteed that the sum of $n<em>{}$ for all test cases does not exceed $10^4</em>{}$.</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p><font face="Consolas">If it is possible to change the string into a palindrome after deleting two letters from $s_{}$, please output “Yes”, otherwise output “No”.</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">abca</span><br><span class="line">6</span><br><span class="line">ababab</span><br><span class="line">6</span><br><span class="line">abcabc</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p><font face="Consolas">自己手写几个例子很容易发现修改不超过 2 次的能构成回文串的字符串都可以，简单说明一下：</p><ol><li>本身是回文串，开头结尾各删一个即可</li><li>删掉一个字符构成回文串，此时的回文串不管长度是奇数还是偶数，删掉中间的那个字符还是回文串</li></ol><p><font face="Consolas">所以我们只需要用 DFS 暴力删除即可，如果删除次数超过 2 返回 0，否则返回 1，在 DFS 的过程中维护两个指针即可，复杂度 $O(4*n)$，AC 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[l] != s[r]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">dfs</span>(l + <span class="number">1</span>, r, cnt - <span class="number">1</span>) || <span class="built_in">dfs</span>(l, r - <span class="number">1</span>, cnt - <span class="number">1</span>) || <span class="built_in">dfs</span>(l + <span class="number">1</span>, r - <span class="number">1</span>, cnt - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">dfs</span>(l + <span class="number">1</span>, r, cnt - <span class="number">1</span>) || <span class="built_in">dfs</span>(l, r - <span class="number">1</span>, cnt - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(l + <span class="number">1</span>, r - <span class="number">1</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(<span class="number">0</span>, n<span class="number">-1</span>, <span class="number">2</span>)) cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> DFS </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1792 最大平均通过率</title>
      <link href="/blog/2021/03/21/LeetCode%201792%20%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E9%80%9A%E8%BF%87%E7%8E%87/"/>
      <url>/blog/2021/03/21/LeetCode%201792%20%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E9%80%9A%E8%BF%87%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/">题目链接</a></p><p><font face="Consolas">一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passi, totali] ，表示你提前知道了第 i 个班级总共有 totali 个学生，其中只有 passi 个学生可以通过考试。</p><p><font face="Consolas">给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。</p><p>一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。平均通过率 是所有班级的通过率之和除以班级数目。</p><p><font face="Consolas">请你返回在安排这 extraStudents 个学生去对应班级后的最大平均通过率。与标准答案误差范围在 $10^{-5}$ 以内的结果都会视为正确结果。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：classes = [[1,2],[3,5],[2,2]], extraStudents = 2</span><br><span class="line">输出：0.78333</span><br><span class="line">解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3/4 + 3/5 + 2/2) / 3 = 0.78333 。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4</span><br><span class="line">输出：0.53485</span><br></pre></td></tr></table></figure><p><font face="Consolas">一开始想的是排序，后来发现变化是动态的，观察到 extraStudents 这个变量不大，那可以就用优先队列一个一个加，我们优先队列存每个班加一个学生之后提升的通过率，设为大根堆，每次对队头操作即可，AC 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">maxAverageRatio</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;classes, <span class="type">int</span> extraStudents)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;tuple&lt;<span class="type">double</span>, <span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;tuple&lt;<span class="type">double</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt;, less&lt;&gt;&gt; q;</span><br><span class="line">        <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:classes)</span><br><span class="line">            sum += <span class="built_in">double</span>(i[<span class="number">0</span>]) / i[<span class="number">1</span>], q.<span class="built_in">push</span>(&#123;<span class="built_in">double</span>(i[<span class="number">0</span>] + <span class="number">1</span>) / (i[<span class="number">1</span>] + <span class="number">1</span>) - <span class="built_in">double</span>(i[<span class="number">0</span>]) / i[<span class="number">1</span>], i[<span class="number">0</span>], i[<span class="number">1</span>]&#125;);</span><br><span class="line">        <span class="keyword">while</span> (extraStudents) &#123;</span><br><span class="line">            extraStudents--;</span><br><span class="line">            <span class="keyword">auto</span>[a, b, c]=q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            sum += a;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;<span class="built_in">double</span>(b + <span class="number">2</span>) / (c + <span class="number">2</span>) - <span class="built_in">double</span>(b + <span class="number">1</span>) / (c + <span class="number">1</span>), b + <span class="number">1</span>, c + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum / classes.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 978 最长湍流子数组</title>
      <link href="/blog/2021/03/21/LeetCode%20978%20%E6%9C%80%E9%95%BF%E6%B9%8D%E6%B5%81%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/blog/2021/03/21/LeetCode%20978%20%E6%9C%80%E9%95%BF%E6%B9%8D%E6%B5%81%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/">题目链接</a></p><p><font face="Consolas">当 A 的子数组 A[i], A[i+1], …, A[j] 满足下列条件时，我们称其为湍流子数组：</p><p><font face="Consolas">若 i &lt;= k &lt; j，当 k 为奇数时， A[k] &gt; A[k+1]，且当 k 为偶数时，A[k] &lt; A[k+1]；<br>或 若 i &lt;= k &lt; j，当 k 为偶数时，A[k] &gt; A[k+1] ，且当 k 为奇数时， A[k] &lt; A[k+1]。<br>也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。</p><p>返回 A 的最大湍流子数组的长度。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[9,4,2,10,7,8,8,1,9]</span><br><span class="line">输出：5</span><br><span class="line">解释：(A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; A[5])</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[4,8,12,16]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[100]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>思维~<br>官方题解有滑窗，有 <font face="Consolas">DP，但是我另辟蹊径，用一种纯思维的方式，首先求两两数的差值，存入 <font face="Consolas">diff 数组：</p><ul><li><font face="Consolas">arr[i]&gt;arr[i+1]，存入 $1$</li><li><font face="Consolas">arr[i]&lt;arr[i+1]，存入 $-1$</li><li><font face="Consolas">arr[i]=arr[i+1]，存入 $0$</li></ul><p>求得这个差值数组之后，我们就所有找的最大长度，无非就是求 $1,-1,\cdots,-1，1$ 序列的最大长度，设一个 $mx$ 变量维护最大值即可，对某一位置 $i$ 判断下面两种情况：</p><ul><li><font face="Consolas">diff[i]=0，此时必须把 mx 置 0，因为差值为 0 时最大长度为 1</li><li><font face="Consolas">diff[i]≠0，若 diff[i]+diff[i+1]=0，mx++；若 diff[i]+diff[i+1]≠0，把 mx 置 1，因为差值不为 0 时的最大长度为 2</li></ul><p>每次循环 <font face="Consolas">ans=max(ans,mx+1)，因为 mx 个差值对应 mx+1 个数，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; diff;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) diff.<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; arr[i + <span class="number">1</span>]) diff.<span class="built_in">emplace_back</span>(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> diff.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = (diff.<span class="built_in">front</span>() ? <span class="number">2</span> : <span class="number">1</span>), mx = (diff.<span class="built_in">front</span>() ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!diff[i]) mx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (diff[i] + diff[i - <span class="number">1</span>] == <span class="number">0</span>) mx++;</span><br><span class="line">                <span class="keyword">else</span> mx = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, mx + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder Beginner Contest 192 D.Base n</title>
      <link href="/blog/2021/03/21/AtCoder%20Beginner%20Contest%20192%20D.Base%20n/"/>
      <url>/blog/2021/03/21/AtCoder%20Beginner%20Contest%20192%20D.Base%20n/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc192/tasks/abc192_d">题目链接</a></p><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a><font face="Consolas">Problem Statement</h2><p><font face="Consolas">Given are a string X consisting of 0 through 9, and an integer M.</p><p><font face="Consolas">Let d be the greatest digit in X.</p><p><font face="Consolas">How many different integers not greater than M can be obtained by choosing an integer n not less than d+1 and seeing X as a base-n number?</p><h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a><font face="Consolas">Sample Input 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">22</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a><font face="Consolas">Sample Output 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a><font face="Consolas">Sample Input 2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">999</span><br><span class="line">1500</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a><font face="Consolas">Sample Output 2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3"></a><font face="Consolas">Sample Input 3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100000000000000000000000000000000000000000000000000000000000</span><br><span class="line">1000000000000000000</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3"></a><font face="Consolas">Sample Output 3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>思维+二分~<br>题意很简单，就是找最大的 <font face="Consolas">n-进制，使得该进制下的 $X \leq M$，很容易想到二分，二分这个最大进制数即可，判断也很好判断，就是模拟 <font face="Consolas">n-进制转十进制，一旦模拟的过程中大于 $M$，立即跳出即可~<br>这题最大的一个坑点在于 $X$ 只有一位的时候，此时任意进制下的 $X$ 都相等，所以只需要判断 $X$ 和 $M$ 的大小即可。我害怕二分模拟的过程中爆 long long，所以用 py 写的，AC 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">input</span>()</span><br><span class="line">m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(x) == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(x) &lt;= m:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">len</span> = <span class="built_in">len</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>):</span><br><span class="line">        ss = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span> - j - <span class="number">1</span>):</span><br><span class="line">            ss *= n</span><br><span class="line">            <span class="keyword">if</span> ss &gt; m:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="built_in">sum</span> += ss * (<span class="built_in">ord</span>(x[j]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span> &gt; m:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = <span class="number">0</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">    d = <span class="built_in">max</span>(d, <span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">l = d</span><br><span class="line">r = <span class="number">10</span> ** <span class="number">18</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> l &lt;= r:</span><br><span class="line">    mid = (l + r) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> check(mid):</span><br><span class="line">        r = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l = mid + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(r - d + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtCoder </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 992 K 个不同整数的子数组</title>
      <link href="/blog/2021/03/21/LeetCode%20992%20K%20%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/blog/2021/03/21/LeetCode%20992%20K%20%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/">题目链接</a></p><p><font face="Consolas">给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定不同的子数组为好子数组。</p><p><font face="Consolas">（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3）</p><p><font face="Consolas">返回 A 中好子数组的数目。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,2,1,2,3], K = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,2,1,3,4], K = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</span><br></pre></td></tr></table></figure><p>思维+双指针~<br>利用双指针，当我们固定左端点时，可以找到<strong>恰好存在 K 个不同整数</strong>的最大右边界 $R$，那么我们只需找到最小左边界 $L$，答案就是 $R-L+1$，那么这个最小左边界怎么找呢，我们可以再加一个指针，这个指针指向<strong>恰好存在 K-1 个不同整数</strong>的最大右边界 $R’$，答案就是 $R-R’$，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num1</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">num2</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l1 = <span class="number">0</span>, l2 = <span class="number">0</span>, r = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!num1[A[r]]) sum1++;</span><br><span class="line">            num1[A[r]]++;</span><br><span class="line">            <span class="keyword">if</span> (!num2[A[r]]) sum2++;</span><br><span class="line">            num2[A[r]]++;</span><br><span class="line">            <span class="keyword">while</span> (sum1 &gt; K) &#123;</span><br><span class="line">                num1[A[l1]]--;</span><br><span class="line">                <span class="keyword">if</span> (!num1[A[l1]]) sum1--;</span><br><span class="line">                l1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (sum2 &gt; K - <span class="number">1</span>) &#123;</span><br><span class="line">                num2[A[l2]]--;</span><br><span class="line">                <span class="keyword">if</span> (!num2[A[l2]]) sum2--;</span><br><span class="line">                l2++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += l2 - l1;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 5710 积压订单中的订单总数</title>
      <link href="/blog/2021/03/21/LeetCode%205710%20%E7%A7%AF%E5%8E%8B%E8%AE%A2%E5%8D%95%E4%B8%AD%E7%9A%84%E8%AE%A2%E5%8D%95%E6%80%BB%E6%95%B0/"/>
      <url>/blog/2021/03/21/LeetCode%205710%20%E7%A7%AF%E5%8E%8B%E8%AE%A2%E5%8D%95%E4%B8%AD%E7%9A%84%E8%AE%A2%E5%8D%95%E6%80%BB%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/">题目链接</a></p><p><font face="Consolas">给你一个二维整数数组 orders ，其中每个 orders[i] = [price_i, amount_i, orderType_i] 表示有 amount_i 笔类型为 orderType_i 、价格为 price_i 的订单。</p><p><font face="Consolas">订单类型 orderTypei 可以分为两种：</p><ul><li><font face="Consolas">0 表示这是一批采购订单 buy</li><li><font face="Consolas">1 表示这是一批销售订单 sell<br>注意，orders[i] 表示一批共计 amount_i 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。</li></ul><p>存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：</p><p><font face="Consolas">如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。<br>反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。<br>输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 $10^9 + 7$ 取余的结果。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><p><img src="https://img-blog.csdnimg.cn/20210321194910310.png?" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]</span><br><span class="line">输出：6</span><br><span class="line">解释：输入订单后会发生下述情况：</span><br><span class="line">- 提交 5 笔采购订单，价格为 10 。没有销售订单，所以这 5 笔订单添加到积压订单中。</span><br><span class="line">- 提交 2 笔销售订单，价格为 15 。没有采购订单的价格大于或等于 15 ，所以这 2 笔订单添加到积压订单中。</span><br><span class="line">- 提交 1 笔销售订单，价格为 25 。没有采购订单的价格大于或等于 25 ，所以这 1 笔订单添加到积压订单中。</span><br><span class="line">- 提交 4 笔采购订单，价格为 30 。前 2 笔采购订单与价格最低（价格为 15）的 2 笔销售订单匹配，从积压订单中删除这 2 笔销售订单。第 3 笔采购订单与价格最低的 1 笔销售订单匹配，销售订单价格为 25 ，从积压订单中删除这 1 笔销售订单。积压订单中不存在更多销售订单，所以第 4 笔采购订单需要添加到积压订单中。</span><br><span class="line">最终，积压订单中有 5 笔价格为 10 的采购订单，和 1 笔价格为 30 的采购订单。所以积压订单中的订单总数为 6 。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]</span><br><span class="line">输出：999999984</span><br><span class="line">解释：输入订单后会发生下述情况：</span><br><span class="line">- 提交 109 笔销售订单，价格为 7 。没有采购订单，所以这 109 笔订单添加到积压订单中。</span><br><span class="line">- 提交 3 笔采购订单，价格为 15 。这些采购订单与价格最低（价格为 7 ）的 3 笔销售订单匹配，从积压订单中删除这 3 笔销售订单。</span><br><span class="line">- 提交 999999995 笔采购订单，价格为 5 。销售订单的最低价为 7 ，所以这 999999995 笔订单添加到积压订单中。</span><br><span class="line">- 提交 1 笔销售订单，价格为 5 。这笔销售订单与价格最高（价格为 5 ）的 1 笔采购订单匹配，从积压订单中删除这 1 笔采购订单。</span><br><span class="line">最终，积压订单中有 (1000000000-3) 笔价格为 7 的销售订单，和 (999999995-1) 笔价格为 5 的采购订单。所以积压订单中的订单总数为 1999999991 ，等于 999999984 % (109 + 7) 。</span><br></pre></td></tr></table></figure><p><font face="Consolas">水题，只要用两个优先队列分别维护 sell 订单和 buy 订单即可，AC 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNumberOfBacklogOrders</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;orders)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; sell;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, less&lt;&gt;&gt; buy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:orders) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sell.<span class="built_in">empty</span>()) buy.<span class="built_in">push</span>(&#123;i[<span class="number">0</span>], i[<span class="number">1</span>]&#125;);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!sell.<span class="built_in">empty</span>() &amp;&amp; i[<span class="number">0</span>] &gt;= sell.<span class="built_in">top</span>().first &amp;&amp; i[<span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i[<span class="number">1</span>] &gt;= sell.<span class="built_in">top</span>().second) &#123;</span><br><span class="line">                            i[<span class="number">1</span>] -= sell.<span class="built_in">top</span>().second;</span><br><span class="line">                            sell.<span class="built_in">pop</span>();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">auto</span> p = sell.<span class="built_in">top</span>();</span><br><span class="line">                            sell.<span class="built_in">pop</span>();</span><br><span class="line">                            sell.<span class="built_in">push</span>(&#123;p.first, p.second - i[<span class="number">1</span>]&#125;);</span><br><span class="line">                            i[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i[<span class="number">1</span>] &gt; <span class="number">0</span>) buy.<span class="built_in">push</span>(&#123;i[<span class="number">0</span>], i[<span class="number">1</span>]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (buy.<span class="built_in">empty</span>()) sell.<span class="built_in">push</span>(&#123;i[<span class="number">0</span>], i[<span class="number">1</span>]&#125;);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!buy.<span class="built_in">empty</span>() &amp;&amp; i[<span class="number">0</span>] &lt;= buy.<span class="built_in">top</span>().first &amp;&amp; i[<span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i[<span class="number">1</span>] &gt;= buy.<span class="built_in">top</span>().second) &#123;</span><br><span class="line">                            i[<span class="number">1</span>] -= buy.<span class="built_in">top</span>().second;</span><br><span class="line">                            buy.<span class="built_in">pop</span>();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">auto</span> p = buy.<span class="built_in">top</span>();</span><br><span class="line">                            buy.<span class="built_in">pop</span>();</span><br><span class="line">                            buy.<span class="built_in">push</span>(&#123;p.first, p.second - i[<span class="number">1</span>]&#125;);</span><br><span class="line">                            i[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i[<span class="number">1</span>] &gt; <span class="number">0</span>) sell.<span class="built_in">push</span>(&#123;i[<span class="number">0</span>], i[<span class="number">1</span>]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!buy.<span class="built_in">empty</span>()) ans = (ans + buy.<span class="built_in">top</span>().second) % mod, buy.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (!sell.<span class="built_in">empty</span>()) ans = (ans + sell.<span class="built_in">top</span>().second) % mod, sell.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 150 逆波兰表达式求值</title>
      <link href="/blog/2021/03/20/Leetcode%20150%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
      <url>/blog/2021/03/20/Leetcode%20150%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">题目链接</a></p><p>根据逆波兰表示法，求表达式的值。</p><p><font face="Consolas">有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">整数除法只保留整数部分。</span><br><span class="line">给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</span><br></pre></td></tr></table></figure><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：</span><br><span class="line">该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure><p>简单栈操作，用一个数字栈存所有数字，每碰到一个运算符，就从栈中取两个数计算出一个结果再存到栈里，最后返回栈顶即可，AC代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> i != <span class="string">&#x27;+&#x27;</span> <span class="keyword">and</span> i != <span class="string">&#x27;-&#x27;</span> <span class="keyword">and</span> i != <span class="string">&#x27;*&#x27;</span> <span class="keyword">and</span> i != <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                num.append(<span class="built_in">int</span>(i))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = num[-<span class="number">1</span>]</span><br><span class="line">                num.pop()</span><br><span class="line">                b = num[-<span class="number">1</span>]</span><br><span class="line">                num.pop()</span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    num.append(a + b)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    num.append(b - a)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    num.append(<span class="built_in">int</span>(b / a))</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    num.append(a * b)</span><br><span class="line">        <span class="keyword">return</span> num[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 59 螺旋矩阵 II</title>
      <link href="/blog/2021/03/16/LeetCode%2059%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20II/"/>
      <url>/blog/2021/03/16/LeetCode%2059%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20II/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">题目链接</a></p><p>给你一个正整数 $n$ ，生成一个包含 $1$ 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的 $n$ x $n$ 正方形矩阵 $matrix$ 。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p>螺旋填数有一些性质我们必须要知道：</p><ul><li>在填数的过程中有上，下，左，右四个边界，且这四个边界会逐渐缩至一个点</li><li>填数始终遵循以下顺序(顺时针)：<br>a.从左到右<br>b.从上到下<br>c.从右到左<br>d.从下到上</li></ul><p>了解上述性质后我们可以设置四个边界变量，然后按填数顺序不断填数即可，AC代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        L, R, U, D = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        ans = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        num, cnt = <span class="number">1</span>, n * n</span><br><span class="line">        <span class="keyword">while</span> num &lt;= cnt:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L, R + <span class="number">1</span>):</span><br><span class="line">                ans[U][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            U += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(U, D + <span class="number">1</span>):</span><br><span class="line">                ans[i][R] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            R -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(R, L - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                ans[D][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            D -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(D, U - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                ans[i][L] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            L += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 54 螺旋矩阵</title>
      <link href="/blog/2021/03/15/LeetCode%2054%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <url>/blog/2021/03/15/LeetCode%2054%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/spiral-matrix/">题目链接</a></p><p><font face="Consolas">给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><p><img src="https://img-blog.csdnimg.cn/20210315164403512.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><p><img src="https://img-blog.csdnimg.cn/20210315164410820.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p>找规律~<br>拿样例来说明，对样例一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">我们先拿出第一个列表元素 [1,2,3]</span><br><span class="line">此时矩阵为 [[4,5,6],[7,8,9]]</span><br><span class="line">我们从矩阵的每一列表元素里各取一个元素组成新矩阵 [[4,7],[5,8],[6,9]]</span><br><span class="line">再倒置，得到 [[6,9],[5,8],[4,7]]</span><br><span class="line">再拿出第一个列表元素 [6,9]</span><br><span class="line">此时矩阵为 [[5,8],[4,7]]</span><br><span class="line">从矩阵的每一列表元素里各取一个元素组成新矩阵 [[5,4],[8,7]]</span><br><span class="line">再倒置，得到 [[8,7],[5,4]]</span><br><span class="line">再拿出第一个列表元素...</span><br><span class="line">直至矩阵为空</span><br></pre></td></tr></table></figure><p><font face="Consolas">对样例二我们发现也是重复上述过程，这个规律的关键就是 <font face="red">从矩阵的每一列表元素里各取一个元素组成新矩阵</font>，而 Python 中恰有这样的一个函数 zip，AC 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> matrix:</span><br><span class="line">            res += matrix.pop(<span class="number">0</span>)</span><br><span class="line">            matrix = <span class="built_in">list</span>(<span class="built_in">zip</span>(*matrix))[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1178 猜字谜</title>
      <link href="/blog/2021/03/11/LeetCode%201178%20%E7%8C%9C%E5%AD%97%E8%B0%9C/"/>
      <url>/blog/2021/03/11/LeetCode%201178%20%E7%8C%9C%E5%AD%97%E8%B0%9C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/">题目链接</a></p><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p><p><font face=“Consolas”>字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底：</p><p><font face=“Consolas”>单词 word 中包含谜面 puzzle 的第一个字母。<br>单词 word 中的每一个字母都可以在谜面 puzzle 中找到。<br>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）都不能作为谜底。<br>返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。</p><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">words = [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], </span><br><span class="line">puzzles = [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]</span><br><span class="line">输出：[1,1,3,2,4,0]</span><br><span class="line">解释：</span><br><span class="line">1 个单词可以作为 &quot;aboveyz&quot; 的谜底 : &quot;aaaa&quot; </span><br><span class="line">1 个单词可以作为 &quot;abrodyz&quot; 的谜底 : &quot;aaaa&quot;</span><br><span class="line">3 个单词可以作为 &quot;abslute&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;</span><br><span class="line">2 个单词可以作为 &quot;absoryz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;</span><br><span class="line">4 个单词可以作为 &quot;actresz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;</span><br><span class="line">没有单词可以作为 &quot;gaswxyz&quot; 的谜底，因为列表中的单词都不含字母 &#x27;g&#x27;。</span><br></pre></td></tr></table></figure><p>位运算+暴力~<br>如果完全采用暴力的方法，光遍历一遍的复杂度就已经达到 $1e9$，所以我们必须要先存储每个单词的状态，有以下两种方法：</p><ul><li>set存储</li><li>通过位运算字符串转换成数字存储</li></ul><p>第一种方法操作比较简单，但是实操超时了；第二种方法比较难想，我们可以用一个 $26$ 位的二进制数表示一个单词，然后用 $map$ 记录每个二进制数的个数；谜面由于只有 $7$ 位，所以可以暴力算出谜面的所有子集可能，依次加入答案即可，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(vector&lt;string&gt; &amp;words, vector&lt;string&gt; &amp;puzzles)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:words) &#123;</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j:i) &#123;</span><br><span class="line">                num |= (<span class="number">1</span> &lt;&lt; (j - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            mp[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:puzzles) &#123;</span><br><span class="line">            <span class="type">int</span> n = i.<span class="built_in">size</span>(), sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); j++) &#123;</span><br><span class="line">                <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">                num |= (<span class="number">1</span> &lt;&lt; (i.<span class="built_in">front</span>() - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n - <span class="number">1</span>; k++) <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; k) &amp; j) num |= (<span class="number">1</span> &lt;&lt; (i[k + <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                sum += mp[num];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 暴力 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 131 分割回文串</title>
      <link href="/blog/2021/03/09/LeetCode%20131%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/blog/2021/03/09/LeetCode%20131%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">题目链接</a></p><p><font face="Consolas">给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p><p>回文串是正着读和反着读都一样的字符串。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p>暴力所有分隔符，显然对一个长为 $n$ 的字符串最多可以划分成 $n$ 个子串，那么我们就可以暴力所有的可能，复杂度 $O(2^n)$~<br>注意最后一个位置必须要切，拿样例 1 举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aab</span><br><span class="line">1: aab|</span><br><span class="line">2: ab|b|</span><br><span class="line">3: a|ab|</span><br><span class="line">4: a|a|b|</span><br></pre></td></tr></table></figure><p>还有一个细节，因为位数固定了，但是小数的二进制位数比大数小，所以小数的二进制数要在前面补 0，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ss = s;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s == ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> &#123;&#123;s&#125;&#125;;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); i++) &#123;</span><br><span class="line">                <span class="type">int</span> pos = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">                vector&lt;string&gt; v;</span><br><span class="line">                string div = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">int</span> num = i;</span><br><span class="line">                <span class="keyword">while</span> (num) &#123;</span><br><span class="line">                    div = <span class="built_in">to_string</span>(num % <span class="number">2</span>) + div;</span><br><span class="line">                    num /= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (div.<span class="built_in">size</span>() &lt; n - <span class="number">1</span>) div = <span class="string">&#x27;0&#x27;</span> + div;</span><br><span class="line">                div += <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (div[j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        string ss = s.<span class="built_in">substr</span>(pos, j - pos + <span class="number">1</span>);</span><br><span class="line">                        v.<span class="built_in">emplace_back</span>(ss);</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="built_in">check</span>(ss)) flag = <span class="number">0</span>;</span><br><span class="line">                        pos = j + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag) ans.<span class="built_in">emplace_back</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1052 爱生气的书店老板</title>
      <link href="/blog/2021/03/06/LeetCode%201052%20%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/"/>
      <url>/blog/2021/03/06/LeetCode%201052%20%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/">题目链接</a></p><p><font face="Consolas">今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p><p><font face="Consolas">在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p><p><font face="Consolas">书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。</p><p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3</span><br><span class="line">输出：16</span><br><span class="line">解释：</span><br><span class="line">书店老板在最后 3 分钟保持冷静。</span><br><span class="line">感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.</span><br></pre></td></tr></table></figure><p>前缀和~<br>记录不算老板情绪的前缀和 $sum1$ 和算老板情绪的前缀和 $sum2$，遍历 $i\in[0,n-X]$，显然对每个 $i$，答案就是 $sum2.back()+sum1[i+X-1]-sum1[i-1]-(sum2[i+X-1]-sum2[i-1])$，这个公式计算的就是此位置往后连续 $X$ 分钟老板的情绪都不生气后增加的满意顾客数量，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSatisfied</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;customers, vector&lt;<span class="type">int</span>&gt; &amp;grumpy, <span class="type">int</span> X)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; sum1, sum2;</span><br><span class="line">        <span class="type">int</span> n = customers.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum1.<span class="built_in">empty</span>()) sum1.<span class="built_in">emplace_back</span>(customers[i]);</span><br><span class="line">            <span class="keyword">else</span> sum1.<span class="built_in">emplace_back</span>(sum1.<span class="built_in">back</span>() + customers[i]);</span><br><span class="line">            <span class="keyword">if</span> (sum2.<span class="built_in">empty</span>()) sum2.<span class="built_in">emplace_back</span>(grumpy[i] ? <span class="number">0</span> : customers[i]);</span><br><span class="line">            <span class="keyword">else</span> sum2.<span class="built_in">emplace_back</span>(sum2.<span class="built_in">back</span>() + (grumpy[i] ? <span class="number">0</span> : customers[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - X; i++)&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sum2.<span class="built_in">back</span>() + sum1[i + X - <span class="number">1</span>] - (i ? sum1[i - <span class="number">1</span>] : <span class="number">0</span>) - (sum2[i + X - <span class="number">1</span>] - (i ? sum2[i - <span class="number">1</span>] : <span class="number">0</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1774 最接近目标价格的甜点成本</title>
      <link href="/blog/2021/03/06/LeetCode%201774%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E4%BB%B7%E6%A0%BC%E7%9A%84%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC/"/>
      <url>/blog/2021/03/06/LeetCode%201774%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E4%BB%B7%E6%A0%BC%E7%9A%84%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/closest-dessert-cost/">题目链接</a></p><p><font face="Consolas">你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则：</p><ul><li>必须选择 一种 冰激凌基料。</li><li>可以添加 一种或多种 配料，也可以不添加任何配料。</li><li>每种类型的配料最多两份 。</li></ul><p>给你以下三个输入：</p><ul><li><font face="Consolas">baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts[i] 表示第 i 种冰激凌基料的价格。</li><li><font face="Consolas">toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts[i] 表示 一份 第 i 种冰激凌配料的价格。</li><li><font face="Consolas">target ，一个整数，表示你制作甜点的目标价格。<br>你希望自己做的甜点总成本尽可能接近目标价格 target 。</li></ul><p><font face="Consolas">返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [1,7], toppingCosts = [3,4], target = 10</span><br><span class="line">输出：10</span><br><span class="line">解释：考虑下面的方案组合（所有下标均从 0 开始）：</span><br><span class="line">- 选择 1 号基料：成本 7</span><br><span class="line">- 选择 1 份 0 号配料：成本 1 x 3 = 3</span><br><span class="line">- 选择 0 份 1 号配料：成本 0 x 4 = 0</span><br><span class="line">总成本：7 + 3 + 0 = 10 。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [2,3], toppingCosts = [4,5,100], target = 18</span><br><span class="line">输出：17</span><br><span class="line">解释：考虑下面的方案组合（所有下标均从 0 开始）：</span><br><span class="line">- 选择 1 号基料：成本 3</span><br><span class="line">- 选择 1 份 0 号配料：成本 1 x 4 = 4</span><br><span class="line">- 选择 2 份 1 号配料：成本 2 x 5 = 10</span><br><span class="line">- 选择 0 份 2 号配料：成本 0 x 100 = 0</span><br><span class="line">总成本：3 + 4 + 10 + 0 = 17 。不存在总成本为 18 的甜点制作方案。</span><br></pre></td></tr></table></figure><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [3,10], toppingCosts = [2,5], target = 9</span><br><span class="line">输出：8</span><br><span class="line">解释：可以制作总成本为 8 和 10 的甜点。返回 8 ，因为这是成本更低的方案。</span><br></pre></td></tr></table></figure><h2 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [10], toppingCosts = [1], target = 1</span><br><span class="line">输出：10</span><br><span class="line">解释：注意，你可以选择不添加任何配料，但你必须选择一种基料。</span><br></pre></td></tr></table></figure><p><font face="Consolas">看一下 n,m 的范围很容易发现就是暴力，复杂度 $O(n*3^m)$，对每种配料考虑不选，选一份，选两份这三种情况即可~<br>DFS 的过程中记录最小答案，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mn = <span class="number">1e9</span>, ans = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">int</span> id, <span class="type">int</span> sum, <span class="type">int</span> m, <span class="type">int</span> res, <span class="type">int</span> base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(sum - res) &lt; mn) &#123;</span><br><span class="line">                mn = <span class="built_in">abs</span>(sum - res);</span><br><span class="line">                ans = sum + base;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(sum - res) == mn) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, sum + base);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(a, id + <span class="number">1</span>, sum, m, res, base);</span><br><span class="line">        <span class="built_in">dfs</span>(a, id + <span class="number">1</span>, sum + a[id], m, res, base);</span><br><span class="line">        <span class="built_in">dfs</span>(a, id + <span class="number">1</span>, sum + <span class="number">2</span> * a[id], m, res, base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">closestCost</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;baseCosts, vector&lt;<span class="type">int</span>&gt; &amp;toppingCosts, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = toppingCosts.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i:baseCosts) &#123;</span><br><span class="line">            <span class="type">int</span> res = target - i;</span><br><span class="line">            <span class="built_in">dfs</span>(toppingCosts, <span class="number">0</span>, <span class="number">0</span>, m, res, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 503 下一个更大元素 II</title>
      <link href="/blog/2021/03/06/LeetCode%20503%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20II/"/>
      <url>/blog/2021/03/06/LeetCode%20503%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20II/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">题目链接</a></p><p><font face="Consolas">给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure><p>单调栈~</p><p><font face="Consolas">栈内存元素下标，栈顶放最小值，对当前的 nums[i]，若栈顶元素 nums[st.top()]&lt;nums[i]，证明 nums[i] 就是栈顶元素的下一个更大元素，直接存入答案就行~<br>题目另外要求可以循环遍历，我们可以采用取模操作进行优化，AC代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[st.<span class="built_in">top</span>()] &lt; nums[i % n]) &#123;</span><br><span class="line">                ans[st.<span class="built_in">top</span>()] = nums[i % n];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i % n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Caddi Programming Contest 2021(AtCoder Beginner Contest 193) F.Zebraness</title>
      <link href="/blog/2021/03/05/Caddi%20Programming%20Contest%202021(AtCoder%20Beginner%20Contest%20193)%20F.Zebraness/"/>
      <url>/blog/2021/03/05/Caddi%20Programming%20Contest%202021(AtCoder%20Beginner%20Contest%20193)%20F.Zebraness/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc193/tasks/abc193_f">题目链接</a></p><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a><font face="Consolas">Problem Statement</h2><p><font face="Consolas">We have a grid with N horizontal rows and N vertical columns.<br>Let (i,j) denote the square at the i-th row from the top and j-th column from the left. A character $c_{i,j}$ describes the color of (i,j).<br>B means the square is painted black; W means the square is painted white; ? means the square is not yet painted.</p><p><font face="Consolas">Takahashi will complete the black-and-white grid by painting each unpainted square black or white.<br>Let the zebraness of the grid be the number of pairs of a black square and a white square sharing a side.<br>Find the maximum possible zebraness of the grid that Takahashi can achieve.</p><h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a><font face="Consolas">Sample Input 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">BB</span><br><span class="line">BW</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a><font face="Consolas">Sample Output 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a><font face="Consolas">Sample Input 2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">BBB</span><br><span class="line">BBB</span><br><span class="line">W?W</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a><font face="Consolas">Sample Output 2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3"></a><font face="Consolas">Sample Input 3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">?????</span><br><span class="line">?????</span><br><span class="line">?????</span><br><span class="line">?????</span><br><span class="line">?????</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3"></a><font face="Consolas">Sample Output 3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">40</span><br></pre></td></tr></table></figure><p>建图+网络流~<br>对一个为 n*n 的矩阵，显然最大值就是 2n(n-1)，那么这题就可以转化成一个最小割(或者最大流)，答案就是最大值减去最小割，建图如下：</p><ul><li><font face="Consolas">每一个点和四周的点连边，流量为 $1$</li><li><font face="Consolas">对所有非 ? 的点，判断奇偶性连一条 inf 边到源点或者汇点</li></ul><p><font face="Consolas">注意算法复杂度，EK 算法可能会超时，要用 Dicnic 算法，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> from, to;</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    <span class="type">int</span> flow;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> f) : <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt; edges;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> d[MAXN];</span><br><span class="line"><span class="type">int</span> cur[MAXN];</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> s, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(from, to, cap, <span class="number">0</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> m = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(m - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(m - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">1</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            edge &amp;e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        edge &amp;e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">dfs</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dicnic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in">sizeof</span>(cur));</span><br><span class="line">        ans += <span class="built_in">dfs</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; c[i];</span><br><span class="line">    s = n * n + <span class="number">1</span>, t = n * n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x = i * n + j;</span><br><span class="line">            <span class="keyword">if</span> (c[i][j] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i + j) % <span class="number">2</span>) <span class="built_in">add</span>(s, x, inf);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">add</span>(x, t, inf);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c[i][j] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i + j) % <span class="number">2</span>) <span class="built_in">add</span>(x, t, inf);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">add</span>(s, x, <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> y = (i + <span class="number">1</span>) * n + j;</span><br><span class="line">                <span class="built_in">add</span>(x, y, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">add</span>(y, x, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> y = i * n + j + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">add</span>(x, y, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">add</span>(y, x, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> * n * (n - <span class="number">1</span>) - <span class="built_in">dicnic</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtCoder </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1438 绝对差不超过限制的最长连续子数组</title>
      <link href="/blog/2021/03/04/LeetCode%201438%20%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/blog/2021/03/04/LeetCode%201438%20%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">题目链接</a></p><p><font face="Consolas">给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。</p><p><font face="Consolas">如果不存在满足条件的子数组，则返回 0 。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [8,2,4,7], <span class="built_in">limit</span> = 4</span><br><span class="line">输出：2 </span><br><span class="line">解释：所有子数组如下：</span><br><span class="line">[8] 最大绝对差 |8-8| = 0 &lt;= 4.</span><br><span class="line">[8,2] 最大绝对差 |8-2| = 6 &gt; 4. </span><br><span class="line">[8,2,4] 最大绝对差 |8-2| = 6 &gt; 4.</span><br><span class="line">[8,2,4,7] 最大绝对差 |8-2| = 6 &gt; 4.</span><br><span class="line">[2] 最大绝对差 |2-2| = 0 &lt;= 4.</span><br><span class="line">[2,4] 最大绝对差 |2-4| = 2 &lt;= 4.</span><br><span class="line">[2,4,7] 最大绝对差 |2-7| = 5 &gt; 4.</span><br><span class="line">[4] 最大绝对差 |4-4| = 0 &lt;= 4.</span><br><span class="line">[4,7] 最大绝对差 |4-7| = 3 &lt;= 4.</span><br><span class="line">[7] 最大绝对差 |7-7| = 0 &lt;= 4. </span><br><span class="line">因此，满足题意的最长子数组的长度为 2 。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,1,2,4,7,2], <span class="built_in">limit</span> = 5</span><br><span class="line">输出：4 </span><br><span class="line">解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 &lt;= 5 。</span><br></pre></td></tr></table></figure><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,2,2,2,4,4,2,2], <span class="built_in">limit</span> = 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>双指针~<br>我们开设两个指针 $l,r$，先移动 $r$ 指针，并记录区间 $[l,r]$ 内的最大值 $mx$ 和最小值 $mn$，显然当 $mx-mn\leq limit$ 时，区间长度就是答案；当条件不满足时，我们只需要固定 $r$ 指针，移动 $l$ 指针即可，即必须缩短区间长度以满足题目所给条件，但是我们移动指针的过程中要同时改变最大最小值，显然光开两个变量是不够的，我提供了两种方法：</p><ul><li>开一个大根堆 $mx$ 和小根堆 $mn$，显然堆顶就是我们要找的最大最小值，维护两个堆即可</li><li>C++里面有一个强大的数据结构 $multiset$（同样是最容易被忽视的数据结构），这个数据结构自动排序且支持元素重复，显然 $multiset$ 的迭代器指向的开头和末尾就是我们要找的最大最小值</li></ul><p>下面两段代码分别对应第一种和第二种方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;&gt;&gt; mx;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; mn;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            cnt[nums[r]]++;</span><br><span class="line">            mx.<span class="built_in">emplace</span>(nums[r]);</span><br><span class="line">            mn.<span class="built_in">emplace</span>(nums[r]);</span><br><span class="line">            <span class="keyword">while</span> (mx.<span class="built_in">top</span>() - mn.<span class="built_in">top</span>() &gt; limit) &#123;</span><br><span class="line">                cnt[nums[l]]--;</span><br><span class="line">                <span class="keyword">while</span> (!cnt[mx.<span class="built_in">top</span>()]) mx.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">while</span> (!cnt[mn.<span class="built_in">top</span>()]) mn.<span class="built_in">pop</span>();</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            temp.<span class="built_in">emplace</span>(nums[r]);</span><br><span class="line">            <span class="keyword">while</span> (*temp.<span class="built_in">rbegin</span>() - *temp.<span class="built_in">begin</span>() &gt; limit) &#123;</span><br><span class="line">                temp.<span class="built_in">erase</span>(temp.<span class="built_in">find</span>(nums[l++]));</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> multiset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 354 俄罗斯套娃信封问题</title>
      <link href="/blog/2021/03/04/LeetCode%20354%20%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2021/03/04/LeetCode%20354%20%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">题目链接</a></p><p><font face="Consolas">给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不允许旋转信封。</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</span><br></pre></td></tr></table></figure><p>非常经典的二维最长上升子序列，对一维的最长上升子序列，我们很熟悉，但是二维的就必须要排序，那么有下面两种排序方案：</p><ul><li>一维正序，二维正序</li><li>一维正序，二维逆序</li></ul><p>相信绝大部分人都会选择第一种排序方案，但是这样一来算法复杂度就会达到 $O(n^2)$(对每一个信封，必须遍历此信封之前的所有信封才能得到最优解)，为了降低时间复杂度，我们可以选择第二种排序方案：<br>即用一个数组装信封，先装入第一个信封，然后对之后的信封 $i$ 直接二分答案数组，判断里面是否有宽高都大于该信封的信封 $j$，如果没有，证明 $i$ 此时是宽高最大的信封，直接装入答案数组；若有，我们就可以用 $i$ 替换 $j$ 的位置以获得更长的俄罗斯套娃，最后信封数组的长度就是答案，算法复杂度 $O(nlogn)$，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] != b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxEnvelopes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (envelopes.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(envelopes.<span class="built_in">begin</span>(), envelopes.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(envelopes[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> n = envelopes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>(), envelopes[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (it == temp.<span class="built_in">end</span>()) temp.<span class="built_in">push_back</span>(envelopes[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> *it = envelopes[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 最长上升子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1004 最大连续1的个数 III</title>
      <link href="/blog/2021/03/03/LeetCode%201004%20%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%20III/"/>
      <url>/blog/2021/03/03/LeetCode%201004%20%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%20III/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">题目链接</a></p><p><font face="Consolas">给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。</p><p><font face="Consolas">返回仅包含 1 的最长（连续）子数组的长度。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 6。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 10。</span><br></pre></td></tr></table></figure><p>双指针~<br>这题和 <a href="https://qianlinyi.cn/2021/02/17/LeetCode%20424%20%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/">LeetCode 424 替换后的最长重复字符</a> 方法一模一样，就是利用双指针的思想找最大区间，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, n = A.<span class="built_in">size</span>(), num0 = <span class="number">0</span>, num1 = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            A[r] ? num1++ : num0++;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, num1);</span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> - mx &gt; K) &#123;</span><br><span class="line">                A[l] ? num1-- : num0--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 995 K 连续位的最小翻转次数</title>
      <link href="/blog/2021/03/02/LeetCode%20995%20K%20%E8%BF%9E%E7%BB%AD%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0/"/>
      <url>/blog/2021/03/02/LeetCode%20995%20K%20%E8%BF%9E%E7%BB%AD%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/">题目链接</a></p><p><font face="Consolas">在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。</p><p><font face="Consolas">返回所需的 K 位翻转的最小次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [0,1,0], K = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：先翻转 A[0]，然后翻转 A[2]。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,1,0], K = 2</span><br><span class="line">输出：-1</span><br><span class="line">解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。</span><br></pre></td></tr></table></figure><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [0,0,0,1,0,1,1,0], K = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]</span><br><span class="line">翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]</span><br><span class="line">翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]</span><br></pre></td></tr></table></figure><p>差分~<br>这种一次连续改 $k$ 位的题就是很经典的差分，我们只需要从左往右扫，碰到 $0$ 就改成 $1$ 即可，注意因为是连续修改，所以要用差分，线段树肯定也行，但是要麻烦许多，做完这题的可以类比牛客寒假训练营的一道题：<a href="https://qianlinyi.cn/2021/02/23/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A55%20D.%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/">题目链接</a>，也是利用差分的性质，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minKBitFlips</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diff</span><span class="params">(A.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            flag += diff[i];</span><br><span class="line">            <span class="keyword">if</span> (flag % <span class="number">2</span>) A[i] ^= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= A.<span class="built_in">size</span>() - K &amp;&amp; !A[i]) &#123;</span><br><span class="line">                A[i] = <span class="number">1</span>;</span><br><span class="line">                ans++;</span><br><span class="line">                diff[i]++;</span><br><span class="line">                diff[i + K]--;</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum != A.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 300 最长递增子序列</title>
      <link href="/blog/2021/03/02/LeetCode%20300%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/blog/2021/03/02/LeetCode%20300%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">题目链接</a></p><p><font face="Consolas">给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p><font face="Consolas">子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>经典 DP，这里挂一个 $O(NlogN)$ 的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">2505</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s &lt;= e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == e) <span class="keyword">return</span> s;</span><br><span class="line">            <span class="type">int</span> mid = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dp[mid] &lt; key) s = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> e = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">-1e9</span>;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; dp[top])</span><br><span class="line">                dp[++top] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> k = <span class="built_in">bs</span>(<span class="number">1</span>, top, nums[i]);</span><br><span class="line">                dp[k] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 最长上升子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder Beginner Contest 192 F.Potion</title>
      <link href="/blog/2021/03/01/AtCoder%20Beginner%20Contest%20192%20F.Potion/"/>
      <url>/blog/2021/03/01/AtCoder%20Beginner%20Contest%20192%20F.Potion/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc192/tasks/abc192_f">题目链接</a></p><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a><font face="Consolas">Problem Statement</h2><p><font face="Consolas">There are N kinds of materials. Material i has a magic power of Ai.</p><p><font face="Consolas">Takahashi, the magician, wants to make a potion by choosing one or more kinds from these materials and mixing them.</p><p><font face="Consolas">At the moment when he makes a potion by mixing k kinds of materials, the magic power of the potion is the sum of the materials used. Then, every second, its magic power increases by k. Note that the increase of the magic power is a discrete - not continuous - process.</p><p><font face="Consolas">Takahashi will mix materials just once, at time 0. What is the earliest time he can get a potion with a magic power of exactly X?</p><p><font face="Consolas">Under the constraints, it can be proved that it is possible to make a potion with a magic power of exactly X.</p><h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a><font face="Consolas">Sample Input 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 9999999999</span><br><span class="line">3 6 8</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a><font face="Consolas">Sample Output 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4999999994</span><br></pre></td></tr></table></figure><h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a><font face="Consolas">Sample Input 2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 1000000000000000000</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">999999999999999999</span><br></pre></td></tr></table></figure><p><font face="Consolas">动态规划，背包DP~</p><p><font face="Consolas">首先我们可以暴力选取材料的种类 $c$，$c\in[1,n]$，用 dp[i][j][k] 表示前 i 个数里选 j 个数且模数为 k 的最大值 sum，且 k=sum%c，则有如下的状态转移方程：</p><script type="math/tex; mode=display">dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - 1][(k - a[i] \% t + t) \% t] + a[i])</script><p>计算出最大值后对应 c 种材料所需时间即为 $t=\frac{x-dp[n][c][x\%c]}{c}$，AC 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n, x, ans = INT64_MAX, a[<span class="number">105</span>], dp[<span class="number">105</span>][<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= n; t++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0x80</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; t; k++) &#123;</span><br><span class="line">                    dp[i][j][k] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j][k], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][(k - a[i] % t + t) % t] + a[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[n][t][x % t] &gt; <span class="number">0</span>) ans = <span class="built_in">min</span>(ans, (x - dp[n][t][x % t]) / t);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtCoder </tag>
            
            <tag> 背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;font face=&quot;Consolas&quot;&gt;Caddi Programming Contest 2021(AtCoder Beginner Contest 193) E.Oversleeping&lt;/font&gt;</title>
      <link href="/blog/2021/03/01/Caddi%20Programming%20Contest%202021(AtCoder%20Beginner%20Contest%20193)%20E.Oversleeping/"/>
      <url>/blog/2021/03/01/Caddi%20Programming%20Contest%202021(AtCoder%20Beginner%20Contest%20193)%20E.Oversleeping/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc193/tasks/abc193_e">题目链接</a></p><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a><font face="Consolas">Problem Statement</h2><p><font face="Consolas">A train goes back and forth between Town A and Town B. It departs Town A at time 0 and then repeats the following:</p><ul><li><font face="Consolas">goes to Town B, taking X seconds;</li><li><font face="Consolas">stops at Town B for Y seconds;</li><li><font face="Consolas">goes to Town A, taking X seconds;</li><li><font face="Consolas">stops at Town A for Y seconds.</li></ul><p><font face="Consolas">More formally, these intervals of time are half-open, that is, for each n=0,1,2,…:</p><ul><li><font face="Consolas">at time t such that (2X+2Y)n≤t&lt;(2X+2Y)n+X, the train is going to Town B;</li><li><font face="Consolas">at time t such that (2X+2Y)n+X≤t&lt;(2X+2Y)n+X+Y, the train is stopping at Town B;</li><li><font face="Consolas">at time t such that (2X+2Y)n+X+Y≤t&lt;(2X+2Y)n+2X+Y, the train is going to Town A;</li><li><font face="Consolas">at time t such that (2X+2Y)n+2X+Y≤t&lt;(2X+2Y)(n+1), the train is stopping at Town A.</li></ul><p><font face="Consolas">Takahashi is thinking of taking this train to depart Town<br>A at time 0 and getting off at Town B. After the departure, he will repeat the following:</p><ul><li><font face="Consolas">be asleep for P seconds;</li><li><font face="Consolas">be awake for Q seconds.</li></ul><p><font face="Consolas">Again, these intervals of time are half-open, that is, for each n=0,1,2,…:</p><ul><li><font face="Consolas">at time t such that (P+Q)n≤t&lt;(P+Q)n+P, Takahashi is asleep;</li><li><font face="Consolas">at time t such that (P+Q)n+P≤t&lt;(P+Q)(n+1), Takahashi is awake.</li></ul><p><font face="Consolas">He can get off the train at Town B if it is stopping at Town B and he is awake.Determine whether he can get off at Town B. If he can, find the earliest possible time to do so.Under the constraints of this problem, it can be proved that the earliest time is an integer.</p><p><font face="Consolas">You are given T cases. Solve each of them.</p><h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a><font face="Consolas">Sample Input 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5 2 7 6</span><br><span class="line">1 1 3 1</span><br><span class="line">999999999 1 1000000000 1</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a><font face="Consolas">Sample Output 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copy</span><br><span class="line">20</span><br><span class="line">infinity</span><br><span class="line">1000000000999999999</span><br></pre></td></tr></table></figure><p>拓展欧几里得~<br>题目就是求一个同余方程组：</p><script type="math/tex; mode=display">\begin{cases}t\equiv t1(mod \ (2X+2Y))\\t\equiv t2(mod \ (P+Q))\\\end{cases}</script><p>两式相减可以得：</p><script type="math/tex; mode=display">(2X+2Y)x-(P+Q)y=t2-t1</script><p>因为题目中的 $Y,Q$ 都比较小，所以 $t1,t2$ 可以暴力遍历，上式可以通过拓展欧几里得定理求得一个特解 $x_0$，所以可以得到 $t$ 的一个特解 $t_0=(2X+2Y)*x_0+t1$，那么通解就是 $t=t_0+LCM(2X+2Y,P+Q)$，题目要求最小的正整数解，只需要将特解 $t_0$ 对 $LCM(2X+2Y,P+Q)$ 取模即可~<br>这题唯一的坑点就是会爆 $ll$，所以在最后算答案的时候要加快速乘，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll X, Y, ans, LCM, x, y, p, q, i, j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Gcd</span><span class="params">(ll A, ll B, ll &amp;gcd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B) &#123;</span><br><span class="line">        <span class="built_in">Gcd</span>(B, A % B, gcd);</span><br><span class="line">        ll t = X;</span><br><span class="line">        X = Y;</span><br><span class="line">        Y = t - (A / B) * Y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        gcd = A;</span><br><span class="line">        X = <span class="number">1</span>, Y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">    ll k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) k = (k + a) % mod;</span><br><span class="line">        a = (a + a) % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(ll A, ll B, ll C)</span> </span>&#123;</span><br><span class="line">    ll gcd;</span><br><span class="line">    <span class="built_in">Gcd</span>(A, B, gcd);</span><br><span class="line">    <span class="keyword">if</span> (C % gcd) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        X = X * (C / gcd);</span><br><span class="line">        <span class="keyword">if</span> (X &lt; <span class="number">0</span>) X = (LCM - (-X) % LCM) % LCM;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, (<span class="built_in">f</span>(<span class="number">2</span> * x + <span class="number">2</span> * y, X, LCM) + i) % LCM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        ans = INT64_MAX;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; p &gt;&gt; q;</span><br><span class="line">        LCM = (<span class="number">2</span> * x + <span class="number">2</span> * y) / __gcd(<span class="number">2</span> * x + <span class="number">2</span> * y, p + q) * (p + q);</span><br><span class="line">        <span class="keyword">for</span> (i = x; i &lt; x + y; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = p; j &lt; p + q; j++) &#123;</span><br><span class="line">                <span class="built_in">exgcd</span>(<span class="number">2</span> * x + <span class="number">2</span> * y, -p - q, j - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == INT64_MAX) cout &lt;&lt; <span class="string">&quot;infinity\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtCoder </tag>
            
            <tag> 拓展欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 5691 通过最少操作次数使数组的和相等</title>
      <link href="/blog/2021/02/28/LeetCode%205691%20%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89/"/>
      <url>/blog/2021/02/28/LeetCode%205691%20%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations/">题目链接</a></p><p><font face="Consolas">给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。</p><p><font face="Consolas">每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。</p><p><font face="Consolas">请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。</span><br><span class="line">- 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2] 。</span><br><span class="line">- 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2] 。</span><br><span class="line">- 将 nums1[2] 变为 2 。 nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2] 。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,1,1,1,1,1,1], nums2 = [6]</span><br><span class="line">输出：-1</span><br><span class="line">解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。</span><br></pre></td></tr></table></figure><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [6,6], nums2 = [1]</span><br><span class="line">输出：3</span><br><span class="line">解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。</span><br><span class="line">- 将 nums1[0] 变为 2 。 nums1 = [2,6], nums2 = [1] 。</span><br><span class="line">- 将 nums1[1] 变为 2 。 nums1 = [2,2], nums2 = [1] 。</span><br><span class="line">- 将 nums2[0] 变为 4 。 nums1 = [2,2], nums2 = [4] 。</span><br></pre></td></tr></table></figure><p> 二分~</p><p><font face="Consolas"> 容易想到二分次数，但是 check 函数比较难想，我们要先计算两个数组和的差值 res，如果次数为 x，试想，我们必须要用 x 次操作使得两个数组的和尽可能接近，一次操作变化的最大值有下面两种情况：</p><ul><li><font face="Consolas">将数组和较大的数组 v1 按从大到小排序，变化的最大值即为 v1.front()-1</li><li><font face="Consolas">将数组和较大的数组 v2 按从小到大排序，变化的最大值即为 6-v2.front()</li></ul><p><font face="Consolas">基于上述的分类，我们可以开两个指针 l1,l2 指向两个数组的开头，在二分的过程中判断是否能让 res=0 即可，AC 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt; &amp;nums2, <span class="type">int</span> res)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l1 = <span class="number">0</span>, l2 = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1 &lt; nums1.<span class="built_in">size</span>() &amp;&amp; l2 &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[l1] - <span class="number">1</span> &gt;= <span class="number">6</span> - nums2[l2]) &#123;</span><br><span class="line">                    res -= nums1[l1] - <span class="number">1</span>;</span><br><span class="line">                    l1++;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res -= <span class="number">6</span> - nums2[l2];</span><br><span class="line">                    l2++;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1 &lt; nums1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                res -= nums1[l1] - <span class="number">1</span>;</span><br><span class="line">                l1++;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                res -= <span class="number">6</span> - nums2[l2];</span><br><span class="line">                l2++;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (cnt &lt;= x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mn1 = nums1.<span class="built_in">size</span>(), mx1 = nums1.<span class="built_in">size</span>() * <span class="number">6</span>;</span><br><span class="line">        <span class="type">int</span> mn2 = nums2.<span class="built_in">size</span>(), mx2 = nums2.<span class="built_in">size</span>() * <span class="number">6</span>;</span><br><span class="line">        <span class="type">int</span> sum1 = <span class="built_in">accumulate</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> sum2 = <span class="built_in">accumulate</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum1 &lt; sum2) <span class="built_in">swap</span>(nums1, nums2);</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">rbegin</span>(), nums1.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">abs</span>(sum1 - sum2);</span><br><span class="line">        <span class="keyword">if</span> (mn2 &gt; mx1 || mn1 &gt; mx2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid, nums1, nums2, res)) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 395 至少有 K 个重复字符的最长子串</title>
      <link href="/blog/2021/02/28/LeetCode%20395%20%E8%87%B3%E5%B0%91%E6%9C%89%20K%20%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/blog/2021/02/28/LeetCode%20395%20%E8%87%B3%E5%B0%91%E6%9C%89%20K%20%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">题目链接</a></p><p>给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaabb&quot;, k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：最长子串为 &quot;aaa&quot; ，其中 &#x27;a&#x27; 重复了 3 次。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ababbc&quot;, k = 2</span><br><span class="line">输出：5</span><br><span class="line">解释：最长子串为 &quot;ababb&quot; ，其中 &#x27;a&#x27; 重复了 2 次， &#x27;b&#x27; 重复了 3 次。</span><br></pre></td></tr></table></figure><p>双指针~<br>这题的关键在于怎么利用双指针找答案，我一开始判断的条件就是两根指针划定的区间的子串每个字符的出现次数，后来发现它并不满足临界点的性质，比如示例2，当子串为 $abab$ 时是满足的，$ababb$ 也是满足的，所以我们无法判断其中一个指针是否到达了临界点~<br>对此我们可以再限制一个条件，就是字符的种类数 $i$，当前子串的种类数大于 $i$ 时，证明已达临界点，我们就可以移动另一个指针了，中间的判断一样，我们可以遍历每一种字符的个数，判断是否满足条件；为了节省时间空间，我们可以开一个 $less$ 变量记录字符的种类数，当某一字符的出现次数达到 $k$ 时，就减 $1$，这样当 $less=0$ 时，一定满足该子串所有字符的出现次数大于等于 $k$~<br>AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubstring</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="type">int</span> tot = <span class="number">0</span>, less = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">                cnt[s[r] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                <span class="keyword">if</span> (cnt[s[r] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    tot++;</span><br><span class="line">                    less++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt[s[r] - <span class="string">&#x27;a&#x27;</span>] == k) less--;</span><br><span class="line">                <span class="keyword">while</span> (tot &gt; i) &#123;</span><br><span class="line">                    cnt[s[l] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                    <span class="keyword">if</span> (cnt[s[l] - <span class="string">&#x27;a&#x27;</span>] == k - <span class="number">1</span>) less++;</span><br><span class="line">                    <span class="keyword">if</span> (cnt[s[l] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) tot--, less--;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!less) ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>);</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 765 情侣牵手</title>
      <link href="/blog/2021/02/27/LeetCode%20765%20%E6%83%85%E4%BE%A3%E7%89%B5%E6%89%8B/"/>
      <url>/blog/2021/02/27/LeetCode%20765%20%E6%83%85%E4%BE%A3%E7%89%B5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/couples-holding-hands/">题目链接</a></p><p><font face="Consolas">N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。</p><p><font face="Consolas">人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N-2, 2N-1)。</p><p>这些情侣的初始座位  row[i] 是由最初始坐在第 i 个座位上的人决定的。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: row = [0, 2, 1, 3]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 我们只需要交换row[1]和row[2]的位置即可。</span><br></pre></td></tr></table></figure><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: row = [3, 2, 0, 1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 无需交换座位，所有的情侣都已经可以手牵手了。</span><br></pre></td></tr></table></figure><p>并查集~<br>学过交换排序的肯定都知道，最多只需要 $n-1$ 次交换就能让长为 $n$ 的数组有序，用到这题同理，我们发现最多只需要 $\frac{n}{2}-1$ 次交换就可以让所有情侣配对，那么怎么计算最少交换次数呢？<br>这里就要用到并查集了，我们考虑每一对情侣就是一个连通分量，最后配对之后的连通分量就是 $\frac{n}{2}$ 对，那么我们只需要计算出开始的连通分量个数 $cnt$，答案就是 $\frac{n}{2}-cnt$ 了，因为每一个配对的情侣编号都是一奇一偶，所以我们可以除 $2$ 来将编号统一，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Unionset</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; father;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sum;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        father.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) father[i] = i;</span><br><span class="line">        sum.<span class="built_in">resize</span>(n);</span><br><span class="line">        cnt = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findFather</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == father[x] ? x : father[x] = <span class="built_in">findFather</span>(father[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">findFather</span>(x), y = <span class="built_in">findFather</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum[x] &lt; sum[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        father[y] = x;</span><br><span class="line">        sum[x] += sum[y];</span><br><span class="line">        --cnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSwapsCouples</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;row)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = row.<span class="built_in">size</span>();</span><br><span class="line">        Unionset u = <span class="built_in">Unionset</span>();</span><br><span class="line">        u.<span class="built_in">init</span>(n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) u.<span class="built_in">Union</span>(row[i] / <span class="number">2</span>, row[i + <span class="number">1</span>] / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> n / <span class="number">2</span> - u.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;font face=&quot;Consolas&quot;&gt;LeetCode 703 数据流中的第 K 大元素</title>
      <link href="/blog/2021/02/26/LeetCode%20703%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC%20K%20%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
      <url>/blog/2021/02/26/LeetCode%20703%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC%20K%20%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">题目链接</a></p><p><font face="Consolas">设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p><p><font face="Consolas">请实现 KthLargest 类：</p><p><font face="Consolas">KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。</p><p><font face="Consolas">int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</p><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]</span><br><span class="line">[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]</span><br></pre></td></tr></table></figure><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[null, 4, 5, 5, 8, 8]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);</span><br><span class="line">kthLargest.add(3);   // return 4</span><br><span class="line">kthLargest.add(5);   // return 5</span><br><span class="line">kthLargest.add(10);  // return 5</span><br><span class="line">kthLargest.add(9);   // return 8</span><br><span class="line">kthLargest.add(4);   // return 8</span><br></pre></td></tr></table></figure><p> 堆~<br> <font face="Consolas">简单数据结构，我们只需要维护一个大小为 k 的小根堆即可，每次 add 操作也只需要比较添加的元素和堆顶元素的大小即可，我写了 C++ 和 Python 的两个代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> siz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        siz = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &lt; k) q.<span class="built_in">emplace</span>(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; q.<span class="built_in">top</span>()) q.<span class="built_in">pop</span>(), q.<span class="built_in">emplace</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() &lt; siz) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(val);</span><br><span class="line">            <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; q.<span class="built_in">top</span>()) <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">emplace</span>(val);</span><br><span class="line">                <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.siz = k</span><br><span class="line">        self.q = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.q) &lt; self.siz:</span><br><span class="line">                heapq.heappush(self.q, i)</span><br><span class="line">            <span class="keyword">elif</span> i &gt; self.q[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(self.q)</span><br><span class="line">                heapq.heappush(self.q, i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.q) &lt; self.siz:</span><br><span class="line">            heapq.heappush(self.q, val)</span><br><span class="line">            <span class="keyword">return</span> self.q[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> val &lt; self.q[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> self.q[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappop(self.q)</span><br><span class="line">                heapq.heappush(self.q, val)</span><br><span class="line">                <span class="keyword">return</span> self.q[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021牛客寒假算法基础集训营1 A.串</title>
      <link href="/blog/2021/02/26/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51%20A.%E4%B8%B2/"/>
      <url>/blog/2021/02/26/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51%20A.%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/9981/A">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>长度不超过 $n$，且包含子序列“us”的、只由小写字母构成的字符串有多少个？ 答案对 $10^9+7$ 取模。<br>所谓子序列，指一个字符串删除部分字符（也可以不删）得到的字符串。</p><p><font face="Consolas">例如，”unoacscc” 包含子序列 “us”，但 “scscucu” 则不包含子序列 “us”</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>一个正整数 $n（2 \leq n \leq 10^6）$</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>一个正整数，为满足条件的字符串数量对 $10^9+7$ 取模的值</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">77</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">874520</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16471619</span><br></pre></td></tr></table></figure><p>排列组合题~<br>我们考虑长度为 $n$ 的字符串的排列：</p><script type="math/tex; mode=display">\underbrace{X,X,\cdots,X}_n</script><p>假设某一位置 $pos$ (本题下标默认从 $1$ 开始) 放上字母 $u$，如下：</p><script type="math/tex; mode=display">\underbrace{X,X,X,u,\cdots,X,X}_n</script><p>显然后面字母 $s$ 的放法有 $n-pos$ 种，这 $n-pos$ 个位置为避免出现重复答案在放完 $s$ 后其他位置只能放除 $s$ 外的 $25$ 个字母，即每一种 $s$ 的摆放答案就是 $25^{n-pos-1}$ 种，一共 $(n-pos)*25^{n-pos-1}$ 种~<br>下面考虑 $pos$ 位置之前的字母放置方案，显然前面的位置可以放任意字母，答案就是 $26^{pos-1}$ 种~<br>综上所述，只需要遍历每一个位置求和即可得到答案：</p><script type="math/tex; mode=display">ans=\sum_{i=1}^{n-1}26^{i-1}*(n-i)*25^{n-i-1}</script><p> 但是题目要求所有长度小于等于 $n$ 的答案，所以有两种方案：</p><ol><li>化简上面的公式</li><li>构造递推式，我采取了这种方法，根据上述公式得到如下递推式：<script type="math/tex; mode=display">\begin{cases}f_2=1\\f_n=n*25^{n-1}+26*f_{n-1},n>2\end{cases}</script></li></ol><p><font color="red">推导过程：</p><p>$f<em>{n+1}=\sum</em>{i=1}^{n}26^{i-1}<em>(n+1-i)</em>25^{n-i}$</p><p>$\ \ \ \ \ \ \ \ \ =n<em>25^{n-1}+[26</em>(n-1)<em>25^{n-2}+26^2</em>(n-2)*25^{n-3}+\cdots+26^{n-1}]$</p><p>$\ \ \ \ \ \ \ \ \ =n<em>25^{n-1}+\sum_{i=1}^{n-1}26^{i}</em>(n-i)*25^{n-i-1}$</p><p>$\ \ \ \ \ \ \ \ \ =n<em>25^{n-1}+26</em>\sum_{i=1}^{n-1}26^{i-1}<em>(n-i)</em>25^{n-i-1}$</p><p>$\ \ \ \ \ \ \ \ \ =n<em>25^{n-1}+26</em>f_n$</p><p>&lt;/font&gt;<br>预处理算出 1e6 内的答案即可，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">power</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">power</span>(a * a % mod, b / <span class="number">2</span>) * (b % <span class="number">2</span> ? a : <span class="number">1</span>) % mod : <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;ll&gt; ans;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        ll sum = (<span class="built_in">power</span>(<span class="number">25</span>, i - <span class="number">1</span>) * i % mod + ans[i - <span class="number">2</span>] * <span class="number">26</span> % mod) % mod;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ans.<span class="built_in">size</span>(); i++) ans[i] = (ans[i - <span class="number">1</span>] + ans[i]) % mod;</span><br><span class="line">    cout &lt;&lt; ans[n - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021牛客寒假算法基础集训营6 E.网格</title>
      <link href="/blog/2021/02/25/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A56%20E.%E7%BD%91%E6%A0%BC/"/>
      <url>/blog/2021/02/25/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A56%20E.%E7%BD%91%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/9986/E">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个 $n$ 行 $m$ 列的网格，第 $i$ 行 $j$ 列上有数字 $a_{i,j}$ 。每个位置需要从上下左右四个方向中选择互相垂直的两个。</p><p>定义 $w(x)=x+popcnt(x)$ ，其中 $popcnt(x)$ 表示 x 的二进制位中 1 的位的数量。</p><p>如果两个相邻的位置 $(x<em>1,y_1),(x_2,y_2)$ 互相位于对方选择的某个方向上，则对答案由 $w(a</em>{x<em>1,y_1}\ xor\ a</em>{x_2,y_2})$  的贡献，其中 $xor$ 表示二进制中的按位异或。</p><p>小 Z 想问你答案的最大值是多少。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>第一行，输入 $n,m$ 。</p><p>接下来 $n$ 行 $m$ 列，输入这个网格。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>输出答案的最大值。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3 </span><br><span class="line">1 3 6</span><br><span class="line">3 2 4</span><br><span class="line">7 4 0</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">38</span><br></pre></td></tr></table></figure><p>动态规划~<br>因为选定的两个方向必须垂直，所以我们可以将竖直方向和水平方向分开计算，假设先计算水平方向的最大值，对某一行 $i$，用 $dp[j][0/1]$ 表示这一列的最大值，$0$ 表示选左边，$1$ 表示选右边，则有如下状态转移方程：</p><ul><li>$dp[j][0]=max(dp[j-1][0],dp[j-1][1]+w(a[i][j-1]\oplus a[i][j])$</li><li>$dp[j][1]=max(dp[j-1][0],dp[j-1][1])$</li></ul><p>每一行的最大值就是 $max(dp[m][0],dp[m][1])$，累加即可，对竖直方向同理，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, ans, a[<span class="number">1005</span>][<span class="number">1005</span>], dp[<span class="number">1005</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a[x1][y1] ^ a[x2][y2]) + __builtin_popcount(a[x1][y1] ^ a[x2][y2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) cin &gt;&gt; a[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[j - <span class="number">1</span>][<span class="number">0</span>], dp[j - <span class="number">1</span>][<span class="number">1</span>] + <span class="built_in">f</span>(i, j - <span class="number">1</span>, i, j));</span><br><span class="line">            dp[j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j - <span class="number">1</span>][<span class="number">0</span>], dp[j - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="built_in">max</span>(dp[m][<span class="number">0</span>], dp[m][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[j - <span class="number">1</span>][<span class="number">0</span>], dp[j - <span class="number">1</span>][<span class="number">1</span>] + <span class="built_in">f</span>(j - <span class="number">1</span>, i, j, i));</span><br><span class="line">            dp[j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j - <span class="number">1</span>][<span class="number">0</span>], dp[j - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="built_in">max</span>(dp[m][<span class="number">0</span>], dp[m][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021牛客寒假算法基础集训营2 J.牛牛想要成为hacker</title>
      <link href="/blog/2021/02/25/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A52%20J.%E7%89%9B%E7%89%9B%E6%83%B3%E8%A6%81%E6%88%90%E4%B8%BAhacker/"/>
      <url>/blog/2021/02/25/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A52%20J.%E7%89%9B%E7%89%9B%E6%83%B3%E8%A6%81%E6%88%90%E4%B8%BAhacker/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/9982/J">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><font face="Consolas">在算法竞赛中”hack”一般指用一组测试数据触发程序的缺陷，从而导致本来通过题目的 AC 代码无法通过该测试数据。<br>一般情况见得比较多的是用 hack 数据导致别人 WA 掉，当然也有一些会导致原本的 AC 代码 TLE 和 MLE。<br>牛牛在一些简单的练习题时遇到了这样一个问题。<br>给定一个大小为 $n$ 的数组 $a(1 \leq a_i \leq 10^9)$，然后请你判断数组元素是否能够从中选出三个组成一个三角形。</p><p>牛牛发现AC通过的代码中有这样一种暴力逻辑，该逻辑的伪代码如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FOR i = 1 ... n</span><br><span class="line">    FOR j = i + 1 ... n</span><br><span class="line">        FOR k = j + 1 ... n</span><br><span class="line">            IF isTriangle(a[i],a[j],a[k])</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line">                EXIT</span><br><span class="line">            END IF</span><br><span class="line">        END FOR</span><br><span class="line">    END FOR</span><br><span class="line">END FOR</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br><span class="line">EXIT</span><br></pre></td></tr></table></figure><p><font face="Consolas">其实就是三重循环枚举数组的三个元素，检查是否为三角形。这段代码很取巧的地方在于它存在一种“短路”逻辑，一旦发现存在三角形就立刻终止程序。</p><p><font face="Consolas">这样在随机数据下其实很容易发现三角形，所以如果数据纯随机，显然这就是一段 AC 代码。</p><p><font face="Consolas">牛牛当然知道这个代码很明显就存在缺陷，如果数据构造的好的话应该可以卡 TLE，但是牛牛发现，他并不会构造出能够 hack 这个暴力算法的数据，所以他请你来帮他。</p><p><font face="Consolas">我们以这段程序调用 isTriangle 的次数作为时间复杂度的计算依据，请你构造数据 hack 这段暴力程序，使它 TLE 掉。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>第一行输入一个正整数 $n(3 \leq n \leq 10^5)$ 表示需要你构造的数组大小。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p><font face="Consolas">输出 $n$ 个正整数，正整数的范围在 $[1,10^9]$ 之间，要求该暴力程序在运行过程中调用 isTriangle 函数的次数不得少于 $min(C_n^3,n^2\left \lfloor log_2n \right \rfloor)$</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 2 2</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 32 64 128 256 512</span><br></pre></td></tr></table></figure><p>思维~</p><p><font face="Consolas">其实没必要深究用啥序列，因为不论等比数列抑或是斐波那契数列最多不过几十项就爆 int 了，所以这题的关键在于构造，我们要卡一个 $n^2<em>log(n)$，则这个数列迭代的最大项数 $a$ 必须满足 $2^{a-1}\geq n$，根据这一点我们可以选定一个等比数列(怕麻烦就直接选斐波那契数列😂)，那么怎么构造呢，我们可以把数列的后 $a-1$ 项提到前面，后面全放第一项，这样第一重循环选择前 $a-1$ 个数时，后面两重循环无论怎么选都无法构成三角形，此时循环次数就是 $O((a-1)</em>n^2)$，而上面又满足 $2^{a-1}\geq n$，所以此时符合题意，AC 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, s = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">29</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        s *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">29</span>; i &lt;= n; i++)</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021牛客寒假算法基础集训营2 D.牛牛与整除分块</title>
      <link href="/blog/2021/02/25/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A52%20D.%E7%89%9B%E7%89%9B%E4%B8%8E%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/"/>
      <url>/blog/2021/02/25/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A52%20D.%E7%89%9B%E7%89%9B%E4%B8%8E%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/9982/D">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>整除分块，又称数论分块。是数论算法中的重要技巧，你可以在各种需要枚举因子的连续求和类问题中见到它的身影。如杜教筛，莫比乌斯反演化简后的整除分段求和等。<br>整除分块基于这样一个数学现象：对于任意正整数 $N$，集合 $S=\left { x:x=\left \lfloor \frac{N}{i} \right \rfloor ,i\in 1,2,3…N \right }$ 的大小总是严格小于 $2 \sqrt N$ 。<br>例如当 $N=10$ 时 $S={10,5,3,2,1}$，这就使得对于 $\left \lfloor \frac{N}{i} \right \rfloor$ 类型的求和类问题，只要快速枚举 $S$ 集合，就能在 $\sqrt N$ 级别的复杂度内解决问题。</p><p>$\left \lfloor \; \; \right \rfloor$ 符号是向下取整符，$\left \lfloor x \right \rfloor$ 表示不大于 $x$ 的最大正整数</p><p>牛牛在学习整除分块这一算法后提出了一个新的问题，对于给定正整数 $N,x$，令$S=\left { x:x=\left \lfloor \frac{N}{i} \right \rfloor ,i\in 1,2,3…N \right }$，时 $\left \lfloor \frac{N}{x} \right \rfloor$在 $S$ 中是第几大呢（去重降序排序后第几个）？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>第一行输入一个正整数 $T(1 \leq T \leq 10^6)$，表示测试案例的数目，对于每组案例。<br>一行两个正整数 $N,x(1 \leq x \leq N \leq 10^9)$</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>对于每个案例，输出一个正整数，即 $\left \lfloor \frac{N}{x} \right \rfloor$ 在集合 $S$ 中降序排第几大。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">25 9</span><br><span class="line">1000000000 1000000000</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">63244</span><br></pre></td></tr></table></figure><p>数论+打表~<br>我一开始直接上分块，但是 $O(T<em>\sqrt n)$ 的复杂度显然不行，所以只能打表找规律~<br>打表很容易发现 $k\leq \sqrt n$ 时答案就是 $k$，而另一半正好对称，我们可以假设 $\sqrt n$ 为一条对称轴，那么对于所有大于 $\sqrt n$ 的数 $num$，都有 $num+\lfloor \frac{n}{num}\rfloor=2</em>\sqrt n$，注意当 $n$ 为完全平方数的时候，对称轴会往左移一个单位，加一个 $bool$ 变量判断即可，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t, n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k &lt;= s ? k : <span class="number">2</span> * s - n / k + (s != n / s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 567 字符串的排列</title>
      <link href="/blog/2021/02/25/LeetCode%20567%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
      <url>/blog/2021/02/25/LeetCode%20567%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutation-in-string/">题目链接</a></p><p><font face="Consolas">给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p>这题暴力的复杂度达到了阶乘级别，显示不可取，首先我们考虑如果有两个等长的字母字符串，如何判断其中一个是另一个的排列~<br>其实换种思路就简单了，我们可以统计每个字母出现的次数，然后一一比较每个字母的次数是否一样即可，假设字符串长为 $n$，则暴力的复杂度为 $O(n!)$，优化后复杂度变为 $O(26*n)$~<br>那如果两个字符串长度不相等(一个为 $m$，一个为 $n$)呢，很简单，我们开设一个大小为 $m$ 的滑窗即可，每次右移只需要将左端点弹出，右端点压入即可，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt1[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;, cnt2[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt1[i] != cnt2[i]) flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s1.<span class="built_in">size</span>(), m = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cnt1[s1[i] - <span class="string">&#x27;a&#x27;</span>]++, cnt2[s2[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; m; i++) &#123;</span><br><span class="line">            cnt2[s2[i - n] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            cnt2[s2[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021牛客寒假算法基础集训营5 B.比武招亲（上）</title>
      <link href="/blog/2021/02/23/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A55%20B.%E6%AF%94%E6%AD%A6%E6%8B%9B%E4%BA%B2%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/blog/2021/02/23/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A55%20B.%E6%AF%94%E6%AD%A6%E6%8B%9B%E4%BA%B2%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="2021牛客寒假算法基础集训营5-B-比武招亲（上）"><a href="#2021牛客寒假算法基础集训营5-B-比武招亲（上）" class="headerlink" title="2021牛客寒假算法基础集训营5 B.比武招亲（上）"></a>2021牛客寒假算法基础集训营5 B.比武招亲（上）</h1><p><a href="https://ac.nowcoder.com/acm/contest/9985/B">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>众所周知，天姐姐只喜欢天下最聪明的人，为了找到这样的人，她决定比武招亲！</p><p>只见天姐姐在榜上留下了这样一道问题，谁做出来了就可以俘获她的芳心！</p><p>爱慕天姐姐已久的泽鸽鸽问询赶来，只见榜上写着：</p><p>给定 $n,m$，定义一种序列，构造方法如下：</p><ol><li><p>在 $[1,n]$ 中任意选择 $m$ 次，得到了 $m$ 个整数（显然数字可能相同）;</p></li><li><p>将选出的 $m$ 个数字排序之后得到一个序列 ${ a<em>{1},a</em>{2},…,a_{m} }$。</p></li></ol><p>定义一个序列的贡献为 $max{ a<em>{1},a</em>{2},…,a<em>{m} }-min{ a</em>{1},a<em>{2},…,a</em>{m}}$，求所有本质不同的序列的贡献和。</p><p>为了防止结果过大，将答案为 $998244353$ 取模后输出。</p><p>（对于两个序列长度为 $m$ 的序列 A、B，若 ${\exists}i∈[1,m]$，$A_i\neq B_i$，则序列 A、B 本质不同）</p><p>泽鸽鸽心有余而力不足，而你作为他最好的基友决定帮助泽鸽鸽俘获美人心！</p><p>现在，这个重任就交给你啦！</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>一行输入两个正整数 $n$，$m$</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>一行一个整数，为答案对 $998244353$ 取模后的结果。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>数论~<br>这种题目最简单的方法就是打表找规律，除非你是数论大师😂<br>很容易发现出现的差值就是 $[0,n-1]$ 一共 $n$ 种情况，关键点就在于这些插值出现了多少次，当 $m=2$ 时，我们很容易找到如下规律：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0:n</span><br><span class="line">1:n-1</span><br><span class="line">2:n-2</span><br><span class="line">......</span><br><span class="line">n-1:1</span><br></pre></td></tr></table></figure><p>而当 $m&gt;2$ 时，出现的次数就是乘上一个 $C^{m-2}_{i+1+m-3},i\in[0,n-1]$，那么我们只需要预处理 $1e6$ 内的组合数，就可以在 $O(n)$ 的时间内算出答案了，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">ll n, m, F[N + <span class="number">1</span>], I[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">power</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">power</span>(a * a % mod, b / <span class="number">2</span>) * (b % <span class="number">2</span> ? a : <span class="number">1</span>) % mod : <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    F[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= N; i++) F[i] = F[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    I[N] = <span class="built_in">power</span>(F[N], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (ll i = N; i--;) &#123;</span><br><span class="line">        I[i] = I[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> F[n] * I[n - k] % mod * I[k] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans = (ans + (n - i) % mod * <span class="built_in">C</span>(i + <span class="number">1</span> + m - <span class="number">3</span>, m - <span class="number">2</span>) % mod * i) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021牛客寒假算法基础集训营5 D.石子游戏</title>
      <link href="/blog/2021/02/23/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A55%20D.%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
      <url>/blog/2021/02/23/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A55%20D.%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="2021牛客寒假算法基础集训营5-D-石子游戏"><a href="#2021牛客寒假算法基础集训营5-D-石子游戏" class="headerlink" title="2021牛客寒假算法基础集训营5 D.石子游戏"></a>2021牛客寒假算法基础集训营5 D.石子游戏</h1><p><a href="https://ac.nowcoder.com/acm/contest/9985/D">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>叶妹妹很喜欢玩石头，于是这天泽鸽鸽给她出了一道石子游戏，规则是这样的：有 $n$ 堆石子排成一行，其中第 $i$ 堆石子有 $a_i$ 个，叶妹妹可以选择做无数次这种操作：每次操作把连续相邻的 $k$ 个石子堆中的每堆石子数目加一，请问叶妹妹能否让每堆石子的数目都相同呢？叶妹妹觉得这题太简单了，于是丢给了聪明的你，快来解决这个问题吧！</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>第一行输入样例组数 $T$</p><p>对于每组样例来说，第一行输入两个数 $n$ 和 $k$</p><p>第二行输入 $n$ 个数，其中第 $i$ 个数为 $a_i$</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>输出总共 $T$ 行，对于每组样例来说，如果能使每堆石子的数目都相同则输出一个整数 $x$，$x$ 表示达到相同时的最少的操作数；否则输出 $-1$</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4 3</span><br><span class="line">1 1 1 2</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>思维+差分~<br>这题我一开始想的是模拟，后来发现复杂度上天，忽然发现，可以用两遍差分来判断，我们先从左往右差分，在遍历的过程中记录最大值，并不断将小于最大值的数修正，不难发现，一遍差分之后该数列下标 $[1,n-k+1]$ 的部分（因为限定连续 $k$ 个数，所以右端点只能到 $n-k+1$）会变成非严格上升子序列，此时只需要再从右往左再进行一遍差分，判断数组是否修正成一样的数即可~<br>想法很简单，但是一边差分一边修正这个过程真的很难写，一不小心就挂了，我具体讲一下用到的两个变量：</p><ul><li><font face="Consolas">diff 数组，记录所有位置的操作次数</li><li><font face="Consolas">sum，记录差分的前后缀和</li></ul><p>这些变量的位置尤为重要，首先我们要先更新 <font face="Consolas">sum，其次更新 <font face="Consolas">a[i]，最后再更新 <font face="Consolas">diff 数组，详见代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> t, n, k;</span><br><span class="line">ll a[N], diff[N], mx, sum, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mx = sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(diff, <span class="number">0</span>, <span class="built_in">sizeof</span>(diff));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += diff[i];</span><br><span class="line">            a[i] += sum;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= n - k + <span class="number">1</span> &amp;&amp; mx &gt; a[i]) &#123;</span><br><span class="line">                ans += mx - a[i], diff[i] += mx - a[i], diff[i + k] -= mx - a[i], sum += mx - a[i], a[i] = mx;</span><br><span class="line">            &#125;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span> (ll i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            sum += diff[i];</span><br><span class="line">            a[i] += sum;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k &amp;&amp; mx &gt; a[i]) &#123;</span><br><span class="line">                ans += mx - a[i], diff[i] += mx - a[i], diff[i - k] -= mx - a[i], sum += mx - a[i], a[i] = mx;</span><br><span class="line">            &#125;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder Beginner Contest 192 E.Train</title>
      <link href="/blog/2021/02/21/AtCoder%20Beginner%20Contest%20192%20E.Train/"/>
      <url>/blog/2021/02/21/AtCoder%20Beginner%20Contest%20192%20E.Train/</url>
      
        <content type="html"><![CDATA[<h1 id="AtCoder-Beginner-Contest-192-E-Train"><a href="#AtCoder-Beginner-Contest-192-E-Train" class="headerlink" title="AtCoder Beginner Contest 192 E.Train"></a><font face="Consolas">AtCoder Beginner Contest 192 E.Train</h1><p><a href="https://atcoder.jp/contests/abc192/tasks/abc192_e">题目链接</a></p><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a><font face="Consolas">Problem Statement</h2><p><font face="Consolas">In the Republic of AtCoder, there are N cities numbered 1 through N and M<br> railroads numbered 1 through M.</p><p><font face="Consolas">Railroad i connects City $A_i$ and City $B_i$ bidirectionally. At time 0, $K_i$, and all subsequent multiples of $K_i$, a train departs from each of these cities and head to the other city. The time each of these trains takes to reach the destination is $T_i$.</p><p><font face="Consolas">You are now at City X. Find the earliest time you can reach City Y when you start the journey by taking a train that departs City X not earlier than time 0. If City Y is unreachable, report that fact.</p><p><font face="Consolas">The time it takes to transfer is ignorable. That is, at every city, you can transfer to a train that departs at the exact time your train arrives at that city.</p><h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a><font face="Consolas">Sample Input 1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 2 1 3</span><br><span class="line">1 2 2 3</span><br><span class="line">2 3 3 4</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a><font face="Consolas">Sample Output 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a><font face="Consolas">Sample Input 2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 2 3 1</span><br><span class="line">1 2 2 3</span><br><span class="line">2 3 3 4</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a><font face="Consolas">Sample Output 2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3"></a><font face="Consolas">Sample Input 3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 0 3 1</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3"></a><font face="Consolas">Sample Output 3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="Sample-Input-4"><a href="#Sample-Input-4" class="headerlink" title="Sample Input 4"></a><font face="Consolas">Sample Input 4</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">9 14 6 7</span><br><span class="line">3 1 4 1</span><br><span class="line">5 9 2 6</span><br><span class="line">5 3 5 8</span><br><span class="line">9 7 9 3</span><br><span class="line">2 3 8 4</span><br><span class="line">6 2 6 4</span><br><span class="line">3 8 3 2</span><br><span class="line">7 9 5 2</span><br><span class="line">8 4 1 9</span><br><span class="line">7 1 6 9</span><br><span class="line">3 9 9 3</span><br><span class="line">7 5 1 5</span><br><span class="line">8 2 9 7</span><br><span class="line">4 9 4 4</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-4"><a href="#Sample-Output-4" class="headerlink" title="Sample Output 4"></a>Sample Output 4</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">26</span><br></pre></td></tr></table></figure><p>最短路~<br>    我们可以把时间看成距离，对任意两点 $A_i$ 和 $B_i$，已知其中一点的时间 $t$，那么到达另一点的时间就是 $\lceil\frac{t}{K_i}\rceil*K_i+T_i$，知道这一点后就可以套最短路计算了，有两种方法：</p><ul><li>dijkstra算法+堆优化</li><li>BFS+堆优化</li></ul><p>两者复杂度差不多，我采取的是后者，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">vector&lt;tuple&lt;<span class="type">int</span>, ll, ll&gt;&gt; G[N];</span><br><span class="line"><span class="type">int</span> n, m, u, v, x, y, vis[N];</span><br><span class="line">ll t, k, d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;ll, <span class="type">int</span>&gt;, vector&lt;pair&lt;ll, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; q;</span><br><span class="line">    <span class="built_in">fill</span>(d, d + N, <span class="number">1e18</span>);</span><br><span class="line">    d[x] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, x&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span>[t, a] = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (a == y) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; d[a]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>[b, t, k]:G[a]) &#123;</span><br><span class="line">            t = (d[a] + k - <span class="number">1</span>) / k * k + t;</span><br><span class="line">            <span class="keyword">if</span> (d[b] &gt; t) &#123;</span><br><span class="line">                d[b] = t;</span><br><span class="line">                q.<span class="built_in">emplace</span>(d[b], b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; t &gt;&gt; k;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v, t, k);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u, t, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">if</span> (d[y] == <span class="number">1e18</span>) cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; d[y];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtCoder </tag>
            
            <tag> BFS </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1208 尽可能使字符串相等</title>
      <link href="/blog/2021/02/21/LeetCode%201208%20%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/"/>
      <url>/blog/2021/02/21/LeetCode%201208%20%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-1208-尽可能使字符串相等"><a href="#LeetCode-1208-尽可能使字符串相等" class="headerlink" title="LeetCode 1208 尽可能使字符串相等"></a>LeetCode 1208 尽可能使字符串相等</h1><p><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/">题目链接</a></p><p><font face="Consolas"><br>给你两个长度相同的字符串，s 和 t。</p><p><font face="Consolas"><br>将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p><p><font face="Consolas"><br>用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p><p><font face="Consolas"><br>如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。</p><p><font face="Consolas"><br>如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, t = &quot;bcdf&quot;, cost = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：s 中的 &quot;abc&quot; 可以变为 &quot;bcd&quot;。开销为 3，所以最大长度为 3。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, t = &quot;cdef&quot;, cost = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。</span><br></pre></td></tr></table></figure><h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, t = &quot;acde&quot;, cost = 0</span><br><span class="line">输出：1</span><br><span class="line">解释：你无法作出任何改动，所以最大长度为 1。</span><br></pre></td></tr></table></figure><p>前缀和+二分~<br>先预处理所有位置差的绝对值的前缀和，然后对每一个位置，二分不超过 <font face="Consolas">cost 的最大位置，不断更新答案即可，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">equalSubstring</span><span class="params">(string s, string t, <span class="type">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dif;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dif.<span class="built_in">empty</span>()) dif.<span class="built_in">push_back</span>(<span class="built_in">abs</span>(s[i] - t[i]));</span><br><span class="line">            <span class="keyword">else</span> dif.<span class="built_in">push_back</span>(<span class="built_in">abs</span>(s[i] - t[i]) + dif.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(s[i] - t[i]) &gt; maxCost) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> pos = <span class="built_in">upper_bound</span>(dif.<span class="built_in">begin</span>(), dif.<span class="built_in">end</span>(), dif[i] + maxCost - <span class="built_in">abs</span>(s[i] - t[i])) - dif.<span class="built_in">begin</span>();</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, pos - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 前后缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 424 替换后的最长重复字符</title>
      <link href="/blog/2021/02/18/LeetCode%20424%20%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/"/>
      <url>/blog/2021/02/18/LeetCode%20424%20%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-424-替换后的最长重复字符"><a href="#LeetCode-424-替换后的最长重复字符" class="headerlink" title="LeetCode 424 替换后的最长重复字符"></a>LeetCode 424 替换后的最长重复字符</h1><p><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">题目链接</a></p><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p>注意：字符串长度 和 k 不会超过 1e4。</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ABAB&quot;, k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：用两个&#x27;A&#x27;替换为两个&#x27;B&#x27;,反之亦然。</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;AABABBA&quot;, k = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">将中间的一个&#x27;A&#x27;替换为&#x27;B&#x27;,字符串变为 &quot;AABBBBA&quot;。</span><br><span class="line">子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。</span><br></pre></td></tr></table></figure><p>双指针，用 $l,r$ 两个指针寻找最大长度，先移动 $r$ 指针，并记录此时 $[l,r]$ 区间内某一字符出现最多的次数 $mx$，显然 $k$ 次替换最大的区间长度就是 $l+mx+k-1$，也即 $r&lt;l+mx+k-1$，一旦 $r$ 指针超过此范围，将 $l$ 指针向右移动即可，整个思路就是先移动右指针，再移动左指针，寻找最大区间长度即可，AC代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> mx = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            num[s[r] - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, num[s[r] - <span class="string">&#x27;A&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> - mx &gt; k) &#123;</span><br><span class="line">                num[s[l] - <span class="string">&#x27;A&#x27;</span>]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 839 相似字符串组</title>
      <link href="/blog/2021/02/16/LeetCode%20839%20%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84/"/>
      <url>/blog/2021/02/16/LeetCode%20839%20%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-839-相似字符串组"><a href="#LeetCode-839-相似字符串组" class="headerlink" title="LeetCode 839 相似字符串组"></a>LeetCode 839 相似字符串组</h1><p><a href="https://leetcode-cn.com/problems/similar-string-groups/">题目链接</a></p><p>如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p><p>例如，”tars” 和 “rats” 是相似的 (交换 0 与 2 的位置)； “rats” 和 “arts” 也是相似的，但是 “star” 不与 “tars”，”rats”，或 “arts” 相似。</p><p>总之，它们通过相似性形成了两个关联组：{“tars”, “rats”, “arts”} 和 {“star”}。注意，”tars” 和 “arts” 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p><p>给你一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。请问 strs 中有多少个相似字符串组？</p><h2 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;omv&quot;,&quot;ovm&quot;]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>并查集~<br>双重循环遍历字符串组，把相似的字符串合并到同一个并查集里，最后找一下并查集里连通块的个数即可，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; f;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findFather</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">findFather</span>(f[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string &amp;a, string &amp;b, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b[i]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSimilarGroups</span><span class="params">(vector&lt;string&gt; &amp;strs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        f.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) f[i] = i;</span><br><span class="line">        <span class="type">int</span> len = strs[<span class="number">0</span>].<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> fi = <span class="built_in">findFather</span>(i), fj = <span class="built_in">findFather</span>(j);</span><br><span class="line">                <span class="keyword">if</span> (fi == fj) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(strs[i], strs[j], len)) &#123;</span><br><span class="line">                    f[fi] = fj;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (f[i] == i) ans++;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 778 水位上升的泳池中游泳</title>
      <link href="/blog/2021/02/16/LeetCode%20778%20%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/"/>
      <url>/blog/2021/02/16/LeetCode%20778%20%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-778-水位上升的泳池中游泳"><a href="#LeetCode-778-水位上升的泳池中游泳" class="headerlink" title="LeetCode 778 水位上升的泳池中游泳"></a>LeetCode 778 水位上升的泳池中游泳</h1><p><a href="https://leetcode-cn.com/problems/swim-in-rising-water/">题目链接</a></p><p>在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。</p><p>现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p><p>你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1，N-1)？</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [[0,2],[1,3]]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">时间为0时，你位于坐标方格的位置为 (0, 0)。</span><br><span class="line">此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。</span><br><span class="line"></span><br><span class="line">等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置</span><br></pre></td></tr></table></figure><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]</span><br><span class="line">输出: 16</span><br><span class="line">解释:</span><br><span class="line">我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的</span><br></pre></td></tr></table></figure><p>二分+BFS~<br>这题跟 <a href="https://qianlinyi.cn/2021/02/15/LeetCode%201631%20%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84/">LeetCode 1631 最小体力消耗路径</a> 几乎一模一样，就是二分最少时间，然后从左上角到右下角 BFS 即可，不同的时 BFS 里面的判别条件稍微改了一下而已，即当前水位高度必须大于等于平台高度，AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n, dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(m * n)</span></span>;</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, b;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            a = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (a.first == m - <span class="number">1</span> &amp;&amp; a.second == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                b.first = a.first + dir[i][<span class="number">0</span>];</span><br><span class="line">                b.second = a.second + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (b.first &gt;= <span class="number">0</span> &amp;&amp; b.first &lt; m &amp;&amp; b.second &gt;= <span class="number">0</span> &amp;&amp; b.second &lt; n &amp;&amp; !vis[b.first * n + b.second] &amp;&amp;</span><br><span class="line">                    grid[b.first][b.second] &lt;= x) &#123;</span><br><span class="line">                    vis[b.first * n + b.second] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">swimInWater</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = grid[<span class="number">0</span>][<span class="number">0</span>], r = <span class="number">2500</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid, grid)) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> BFS </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021牛客寒假算法基础集训营3 H.数字串</title>
      <link href="/blog/2021/02/15/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A53%20H.%E6%95%B0%E5%AD%97%E4%B8%B2/"/>
      <url>/blog/2021/02/15/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A53%20H.%E6%95%B0%E5%AD%97%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="2021牛客寒假算法基础集训营3-H-数字串"><a href="#2021牛客寒假算法基础集训营3-H-数字串" class="headerlink" title="2021牛客寒假算法基础集训营3 H.数字串"></a>2021牛客寒假算法基础集训营3 H.数字串</h1><p><a href="https://ac.nowcoder.com/acm/contest/9983/H">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛牛发现了一种方法可以将只包含小写字母的字符串按照以下方式使其转换成一个数字串：<br>取其中的每个字母，$\mathit a$ 转换为 $\text 1$，$\mathit b$ 转换为 $\text 2……\mathit z$ 转换为 $\text 26$，然后将这些数字拼接起来。<br>例如，$\mathit abcz$ 可以转换为 $\text 12326$。<br>现在给出一个只包含小写字母的字符串 $\mathit S$，你需要找到一个只包含小写字母的字符串 $\mathit T$，使得两个串不相同但是能转换成相同的数字串。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>一行一个长度不超过 $10^{6}$ 的小写字母字符串 $\mathit S$。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>一行一个长度不超过 $2×10^{6}$ 的小写字母字符串 $\mathit T$。<br>如果无解，请输出 $\text -1$。<br>如果答案有解且你输出的字符串包含了除了小写字母以外的字符或长度超过了 $2×10^{6}$，那么你会得到“答案错误”的返回结果。<br>否则如果答案有解且你的答案与输入的字符串可以转换为一样的数字串，那么你的答案会被认为是正确的。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cwc</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cbcc</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ccc</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p>打 <font face="Consalos">ACM 的同仁们可以多了解一下 <font face="Consalos">py，针对字符串类 <font face="Consalos">py 提供了大量现成的函数，非常方便，拿这题举例，我们很容易发现替换其实就是以下几种情况：</p><ul><li>$aa&lt;-&gt;k$</li><li>$ab&lt;-&gt;l$</li><li>$ac&lt;-&gt;m$</li><li>$\cdots$</li><li>$bf&lt;-&gt;z$</li></ul><p>也就是说我们只需要把上述情况都试一遍，如果替换之后都和原串一样，直接输出 $-1$ 即可，如果替换之后和原串不一样就是正确答案，注意 $t$ 这个字符对应的 $20$ 无法转换成两个字符，特判掉即可，上述的替换在 <font face="Consalos">py 里直接有一个 <font face="Consalos">replace 函数，AC代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>, <span class="number">27</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">20</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    a = s.replace(<span class="built_in">chr</span>(<span class="number">97</span> + i - <span class="number">1</span>), <span class="built_in">chr</span>(<span class="number">97</span> + i // <span class="number">10</span> - <span class="number">1</span>) + <span class="built_in">chr</span>(<span class="number">97</span> + i % <span class="number">10</span> - <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> a != s:</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    a = s.replace(<span class="built_in">chr</span>(<span class="number">97</span> + i // <span class="number">10</span> - <span class="number">1</span>) + <span class="built_in">chr</span>(<span class="number">97</span> + i % <span class="number">10</span> - <span class="number">1</span>), <span class="built_in">chr</span>(<span class="number">97</span> + i - <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> a != s:</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021牛客寒假算法基础集训营3 G.糖果</title>
      <link href="/blog/2021/02/15/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A53%20G.%E7%B3%96%E6%9E%9C/"/>
      <url>/blog/2021/02/15/2021%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A53%20G.%E7%B3%96%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="2021牛客寒假算法基础集训营3-G-糖果"><a href="#2021牛客寒假算法基础集训营3-G-糖果" class="headerlink" title="2021牛客寒假算法基础集训营3 G.糖果"></a>2021牛客寒假算法基础集训营3 G.糖果</h1><p><a href="https://ac.nowcoder.com/acm/contest/9983/G">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个幼儿园里面有 $\mathit n$ 个小朋友，分别编号 $\text 1,2,…,n$。在这些小朋友中有一些小朋友互为朋友关系，总共有 $\mathit m$ 对朋友。<br>作为幼儿园老师，你想买一些糖果分给小朋友，你知道第 $\mathit i$ 个小朋友想要至少 $a_{i}$ 个糖果，否则他就会不开心。<br>同时，如果一个小朋友得到的糖果数小于他某个朋友得到的糖果数，他也会不开心。<br>请问你最少买多少糖果才能保证每个小朋友都不会不开心呢？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>第一行以空格分隔的两个整数 $\mathit n,m$。<br>第二行以空格分隔的 $\mathit n$ 个正整数 $a<em>{i}$。<br>接下来 $\mathit m$ 行每行以空格分隔的两个正整数 $\mathit u,v$u,v，代表 $\mathit u$ 是 $\mathit v$ 的朋友，$\mathit v$ 是 $\mathit u$ 的朋友。<br>$1\leq n\leq 10^{6}$<br>$0\leq m\leq 10^{6}$<br>$1\leq a</em>{i} \leq 10^{9}$<br>$1\leq u,v \leq n,u≠v$</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>购买的最少糖果数以保证每个小朋友都不会不开心。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 1</span><br><span class="line">1 2 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><p>DFS~<br>显然我们可以根据朋友关系把图分成很多个连通块，在每一个连通块中，可以求出连通块中元素的数量 $cnt$ 和最大糖果数量 $a$，则最后的答案即为：</p><script type="math/tex; mode=display">ans=\sum(cnt_i*a_i)</script><p>AC代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, u, v, vis[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line">ll ans, cnt, mx, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    cnt++;</span><br><span class="line">    mx = <span class="built_in">max</span>(mx, a[x]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y:G[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[y]) <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            cnt = mx = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            ans += cnt * mx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM算法分类及完成情况</title>
      <link href="/blog/2021/02/02/ACM%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB%E5%8F%8A%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/"/>
      <url>/blog/2021/02/02/ACM%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB%E5%8F%8A%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="ACM算法分类及完成情况"><a href="#ACM算法分类及完成情况" class="headerlink" title="ACM算法分类及完成情况"></a>ACM算法分类及完成情况</h1><p>今天闲着无聊，就把ACM的算法分类记录了一下(若有遗漏，后续会补充)顺便记录一下自己的学习进度，嘻嘻(●’◡’●)，编程之路，道阻且长，继续加油！愿所有努力的人都能有所收获！</p><script type="math/tex; mode=display">ACM算法分类\begin{cases}基本算法\begin{cases}枚举✔\\贪心✔\\递归和分治✔\\递推✔\\构造✔\\模拟✔\\\end{cases}\\搜索\begin{cases}深度优先搜索✔\\广度优先搜索✔\\双向搜索✔\\A^*\\IDA^*\\记忆化搜索✔\\\end{cases}\\计算几何\begin{cases}几何公式✔\\叉积和点积的运用✔\\多边形的简单算法✔\\凸包\\扫描线算法\\多边形的内核\\几何工具的综合应用\\半平面求交\\可视图的建立\\点集最小圆覆盖\\对踵点\\\end{cases}\\数学\begin{cases}组合数学\begin{cases}挂列组合✔\\递推关系✔\\容斥原理\\抽屉原理\\置换群与Polya定理\\母函数\\MoBius反演\\偏序关系理论\\\end{cases}\\数论\begin{cases}素数与整除问题✔\\进制位✔\\同余模运算✔\\高斯消元\\概率问题✔\\扩展欧几里德✔\\矩阵✔\\\end{cases}\\博弈论\begin{cases}极大极小过程\\Nim博弈✔\\\end{cases}\\\end{cases}\\图论\begin{cases}拓扑排序✔\\最小生成树✔\\最短路✔\\二分图✔\\\begin{cases}匈牙利算法✔\\KM算法✔\\带花树算法✔\\\end{cases}\\网络流\begin{cases}最小费用最大流\\最小割模型、网络流规约\end{cases}\\差分约束系统建立与求解\\双连通分量\\强连通分支及其缩点\\图的割边与割点\\\end{cases}\\动态规划\begin{cases}背包问题\begin{cases}01背包✔\\完全背包\\多维背包\\多重背包\\\end{cases}\\基本DP\begin{cases}区间DP\\环形DP\\判定型DP\\棋盘分割\\最长公共子序列✔\\最长上升子序列✔\\\end{cases}\\二分判定型DP\\树型动态规划　最大独立集\\状态压缩DP✔　哈密顿路径问题\\四边形不等式理论\\单调队列优化\\\end{cases}\\数据结构\begin{cases}字符串\begin{cases}KMP✔\\拓展KMP✔\\Manacher✔\\\end{cases}\\排序\begin{cases}快排✔\\归并排（逆序数）\\堆排\\\end{cases}\\哈希表\\二分✔\\并查集✔\\哈夫曼树✔\\堆✔\\线段树✔\\二叉树✔\\树状数组✔\\RMQ✔\\\end{cases}\\\end{cases}</script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
